var data = {lines:[
{"lineNum":"    1","line":"// Vector implementation -*- C++ -*-"},
{"lineNum":"    2","line":""},
{"lineNum":"    3","line":"// Copyright (C) 2001-2019 Free Software Foundation, Inc."},
{"lineNum":"    4","line":"//"},
{"lineNum":"    5","line":"// This file is part of the GNU ISO C++ Library.  This library is free"},
{"lineNum":"    6","line":"// software; you can redistribute it and/or modify it under the"},
{"lineNum":"    7","line":"// terms of the GNU General Public License as published by the"},
{"lineNum":"    8","line":"// Free Software Foundation; either version 3, or (at your option)"},
{"lineNum":"    9","line":"// any later version."},
{"lineNum":"   10","line":""},
{"lineNum":"   11","line":"// This library is distributed in the hope that it will be useful,"},
{"lineNum":"   12","line":"// but WITHOUT ANY WARRANTY; without even the implied warranty of"},
{"lineNum":"   13","line":"// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the"},
{"lineNum":"   14","line":"// GNU General Public License for more details."},
{"lineNum":"   15","line":""},
{"lineNum":"   16","line":"// Under Section 7 of GPL version 3, you are granted additional"},
{"lineNum":"   17","line":"// permissions described in the GCC Runtime Library Exception, version"},
{"lineNum":"   18","line":"// 3.1, as published by the Free Software Foundation."},
{"lineNum":"   19","line":""},
{"lineNum":"   20","line":"// You should have received a copy of the GNU General Public License and"},
{"lineNum":"   21","line":"// a copy of the GCC Runtime Library Exception along with this program;"},
{"lineNum":"   22","line":"// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see"},
{"lineNum":"   23","line":"// <http://www.gnu.org/licenses/>."},
{"lineNum":"   24","line":""},
{"lineNum":"   25","line":"/*"},
{"lineNum":"   26","line":" *"},
{"lineNum":"   27","line":" * Copyright (c) 1994"},
{"lineNum":"   28","line":" * Hewlett-Packard Company"},
{"lineNum":"   29","line":" *"},
{"lineNum":"   30","line":" * Permission to use, copy, modify, distribute and sell this software"},
{"lineNum":"   31","line":" * and its documentation for any purpose is hereby granted without fee,"},
{"lineNum":"   32","line":" * provided that the above copyright notice appear in all copies and"},
{"lineNum":"   33","line":" * that both that copyright notice and this permission notice appear"},
{"lineNum":"   34","line":" * in supporting documentation.  Hewlett-Packard Company makes no"},
{"lineNum":"   35","line":" * representations about the suitability of this software for any"},
{"lineNum":"   36","line":" * purpose.  It is provided \"as is\" without express or implied warranty."},
{"lineNum":"   37","line":" *"},
{"lineNum":"   38","line":" *"},
{"lineNum":"   39","line":" * Copyright (c) 1996"},
{"lineNum":"   40","line":" * Silicon Graphics Computer Systems, Inc."},
{"lineNum":"   41","line":" *"},
{"lineNum":"   42","line":" * Permission to use, copy, modify, distribute and sell this software"},
{"lineNum":"   43","line":" * and its documentation for any purpose is hereby granted without fee,"},
{"lineNum":"   44","line":" * provided that the above copyright notice appear in all copies and"},
{"lineNum":"   45","line":" * that both that copyright notice and this permission notice appear"},
{"lineNum":"   46","line":" * in supporting documentation.  Silicon Graphics makes no"},
{"lineNum":"   47","line":" * representations about the suitability of this  software for any"},
{"lineNum":"   48","line":" * purpose.  It is provided \"as is\" without express or implied warranty."},
{"lineNum":"   49","line":" */"},
{"lineNum":"   50","line":""},
{"lineNum":"   51","line":"/** @file bits/stl_vector.h"},
{"lineNum":"   52","line":" *  This is an internal header file, included by other library headers."},
{"lineNum":"   53","line":" *  Do not attempt to use it directly. @headername{vector}"},
{"lineNum":"   54","line":" */"},
{"lineNum":"   55","line":""},
{"lineNum":"   56","line":"#ifndef _STL_VECTOR_H"},
{"lineNum":"   57","line":"#define _STL_VECTOR_H 1"},
{"lineNum":"   58","line":""},
{"lineNum":"   59","line":"#include <bits/stl_iterator_base_funcs.h>"},
{"lineNum":"   60","line":"#include <bits/functexcept.h>"},
{"lineNum":"   61","line":"#include <bits/concept_check.h>"},
{"lineNum":"   62","line":"#if __cplusplus >= 201103L"},
{"lineNum":"   63","line":"#include <initializer_list>"},
{"lineNum":"   64","line":"#endif"},
{"lineNum":"   65","line":""},
{"lineNum":"   66","line":"#include <debug/assertions.h>"},
{"lineNum":"   67","line":""},
{"lineNum":"   68","line":"#if _GLIBCXX_SANITIZE_STD_ALLOCATOR && _GLIBCXX_SANITIZE_VECTOR"},
{"lineNum":"   69","line":"extern \"C\" void"},
{"lineNum":"   70","line":"__sanitizer_annotate_contiguous_container(const void*, const void*,"},
{"lineNum":"   71","line":"\t\t\t\t\t  const void*, const void*);"},
{"lineNum":"   72","line":"#endif"},
{"lineNum":"   73","line":""},
{"lineNum":"   74","line":"namespace std _GLIBCXX_VISIBILITY(default)"},
{"lineNum":"   75","line":"{"},
{"lineNum":"   76","line":"_GLIBCXX_BEGIN_NAMESPACE_VERSION"},
{"lineNum":"   77","line":"_GLIBCXX_BEGIN_NAMESPACE_CONTAINER"},
{"lineNum":"   78","line":""},
{"lineNum":"   79","line":"  /// See bits/stl_deque.h\'s _Deque_base for an explanation."},
{"lineNum":"   80","line":"  template<typename _Tp, typename _Alloc>"},
{"lineNum":"   81","line":"    struct _Vector_base"},
{"lineNum":"   82","line":"    {"},
{"lineNum":"   83","line":"      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template"},
{"lineNum":"   84","line":"\trebind<_Tp>::other _Tp_alloc_type;"},
{"lineNum":"   85","line":"      typedef typename __gnu_cxx::__alloc_traits<_Tp_alloc_type>::pointer"},
{"lineNum":"   86","line":"       \tpointer;"},
{"lineNum":"   87","line":""},
{"lineNum":"   88","line":"      struct _Vector_impl_data"},
{"lineNum":"   89","line":"      {"},
{"lineNum":"   90","line":"\tpointer _M_start;"},
{"lineNum":"   91","line":"\tpointer _M_finish;"},
{"lineNum":"   92","line":"\tpointer _M_end_of_storage;"},
{"lineNum":"   93","line":""},
{"lineNum":"   94","line":"\t_Vector_impl_data() _GLIBCXX_NOEXCEPT","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   95","line":"\t: _M_start(), _M_finish(), _M_end_of_storage()","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   96","line":"\t{ }","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"   97","line":""},
{"lineNum":"   98","line":"#if __cplusplus >= 201103L"},
{"lineNum":"   99","line":"\t_Vector_impl_data(_Vector_impl_data&& __x) noexcept","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  100","line":"\t: _M_start(__x._M_start), _M_finish(__x._M_finish),","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  101","line":"\t  _M_end_of_storage(__x._M_end_of_storage)","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  102","line":"\t{ __x._M_start = __x._M_finish = __x._M_end_of_storage = pointer(); }","class":"lineNoCov","hits":"0","possible_hits":"7",},
{"lineNum":"  103","line":"#endif"},
{"lineNum":"  104","line":""},
{"lineNum":"  105","line":"\tvoid"},
{"lineNum":"  106","line":"\t_M_copy_data(_Vector_impl_data const& __x) _GLIBCXX_NOEXCEPT","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  107","line":"\t{"},
{"lineNum":"  108","line":"\t  _M_start = __x._M_start;","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  109","line":"\t  _M_finish = __x._M_finish;","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  110","line":"\t  _M_end_of_storage = __x._M_end_of_storage;","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  111","line":"\t}","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  112","line":""},
{"lineNum":"  113","line":"\tvoid"},
{"lineNum":"  114","line":"\t_M_swap_data(_Vector_impl_data& __x) _GLIBCXX_NOEXCEPT","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  115","line":"\t{"},
{"lineNum":"  116","line":"\t  // Do not use std::swap(_M_start, __x._M_start), etc as it loses"},
{"lineNum":"  117","line":"\t  // information used by TBAA."},
{"lineNum":"  118","line":"\t  _Vector_impl_data __tmp;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  119","line":"\t  __tmp._M_copy_data(*this);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  120","line":"\t  _M_copy_data(__x);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  121","line":"\t  __x._M_copy_data(__tmp);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  122","line":"\t}","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  123","line":"      };"},
{"lineNum":"  124","line":""},
{"lineNum":"  125","line":"      struct _Vector_impl","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  126","line":"\t: public _Tp_alloc_type, public _Vector_impl_data"},
{"lineNum":"  127","line":"      {"},
{"lineNum":"  128","line":"\t_Vector_impl() _GLIBCXX_NOEXCEPT_IF(","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  129","line":"\t    is_nothrow_default_constructible<_Tp_alloc_type>::value)"},
{"lineNum":"  130","line":"\t: _Tp_alloc_type()","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  131","line":"\t{ }","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  132","line":""},
{"lineNum":"  133","line":"\t_Vector_impl(_Tp_alloc_type const& __a) _GLIBCXX_NOEXCEPT","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  134","line":"\t: _Tp_alloc_type(__a)","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  135","line":"\t{ }","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  136","line":""},
{"lineNum":"  137","line":"#if __cplusplus >= 201103L"},
{"lineNum":"  138","line":"\t// Not defaulted, to enforce noexcept(true) even when"},
{"lineNum":"  139","line":"\t// !is_nothrow_move_constructible<_Tp_alloc_type>."},
{"lineNum":"  140","line":"\t_Vector_impl(_Vector_impl&& __x) noexcept","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  141","line":"\t: _Tp_alloc_type(std::move(__x)), _Vector_impl_data(std::move(__x))","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  142","line":"\t{ }","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  143","line":""},
{"lineNum":"  144","line":"\t_Vector_impl(_Tp_alloc_type&& __a) noexcept"},
{"lineNum":"  145","line":"\t: _Tp_alloc_type(std::move(__a))"},
{"lineNum":"  146","line":"\t{ }"},
{"lineNum":"  147","line":""},
{"lineNum":"  148","line":"\t_Vector_impl(_Tp_alloc_type&& __a, _Vector_impl&& __rv) noexcept"},
{"lineNum":"  149","line":"\t: _Tp_alloc_type(std::move(__a)), _Vector_impl_data(std::move(__rv))"},
{"lineNum":"  150","line":"\t{ }"},
{"lineNum":"  151","line":"#endif"},
{"lineNum":"  152","line":""},
{"lineNum":"  153","line":"#if _GLIBCXX_SANITIZE_STD_ALLOCATOR && _GLIBCXX_SANITIZE_VECTOR"},
{"lineNum":"  154","line":"\ttemplate<typename = _Tp_alloc_type>"},
{"lineNum":"  155","line":"\t  struct _Asan"},
{"lineNum":"  156","line":"\t  {"},
{"lineNum":"  157","line":"\t    typedef typename __gnu_cxx::__alloc_traits<_Tp_alloc_type>"},
{"lineNum":"  158","line":"\t      ::size_type size_type;"},
{"lineNum":"  159","line":""},
{"lineNum":"  160","line":"\t    static void _S_shrink(_Vector_impl&, size_type) { }"},
{"lineNum":"  161","line":"\t    static void _S_on_dealloc(_Vector_impl&) { }"},
{"lineNum":"  162","line":""},
{"lineNum":"  163","line":"\t    typedef _Vector_impl& _Reinit;"},
{"lineNum":"  164","line":""},
{"lineNum":"  165","line":"\t    struct _Grow"},
{"lineNum":"  166","line":"\t    {"},
{"lineNum":"  167","line":"\t      _Grow(_Vector_impl&, size_type) { }"},
{"lineNum":"  168","line":"\t      void _M_grew(size_type) { }"},
{"lineNum":"  169","line":"\t    };"},
{"lineNum":"  170","line":"\t  };"},
{"lineNum":"  171","line":""},
{"lineNum":"  172","line":"\t// Enable ASan annotations for memory obtained from std::allocator."},
{"lineNum":"  173","line":"\ttemplate<typename _Up>"},
{"lineNum":"  174","line":"\t  struct _Asan<allocator<_Up> >"},
{"lineNum":"  175","line":"\t  {"},
{"lineNum":"  176","line":"\t    typedef typename __gnu_cxx::__alloc_traits<_Tp_alloc_type>"},
{"lineNum":"  177","line":"\t      ::size_type size_type;"},
{"lineNum":"  178","line":""},
{"lineNum":"  179","line":"\t    // Adjust ASan annotation for [_M_start, _M_end_of_storage) to"},
{"lineNum":"  180","line":"\t    // mark end of valid region as __curr instead of __prev."},
{"lineNum":"  181","line":"\t    static void"},
{"lineNum":"  182","line":"\t    _S_adjust(_Vector_impl& __impl, pointer __prev, pointer __curr)"},
{"lineNum":"  183","line":"\t    {"},
{"lineNum":"  184","line":"\t      __sanitizer_annotate_contiguous_container(__impl._M_start,"},
{"lineNum":"  185","line":"\t\t  __impl._M_end_of_storage, __prev, __curr);"},
{"lineNum":"  186","line":"\t    }"},
{"lineNum":"  187","line":""},
{"lineNum":"  188","line":"\t    static void"},
{"lineNum":"  189","line":"\t    _S_grow(_Vector_impl& __impl, size_type __n)"},
{"lineNum":"  190","line":"\t    { _S_adjust(__impl, __impl._M_finish, __impl._M_finish + __n); }"},
{"lineNum":"  191","line":""},
{"lineNum":"  192","line":"\t    static void"},
{"lineNum":"  193","line":"\t    _S_shrink(_Vector_impl& __impl, size_type __n)"},
{"lineNum":"  194","line":"\t    { _S_adjust(__impl, __impl._M_finish + __n, __impl._M_finish); }"},
{"lineNum":"  195","line":""},
{"lineNum":"  196","line":"\t    static void"},
{"lineNum":"  197","line":"\t    _S_on_dealloc(_Vector_impl& __impl)"},
{"lineNum":"  198","line":"\t    {"},
{"lineNum":"  199","line":"\t      if (__impl._M_start)"},
{"lineNum":"  200","line":"\t\t_S_adjust(__impl, __impl._M_finish, __impl._M_end_of_storage);"},
{"lineNum":"  201","line":"\t    }"},
{"lineNum":"  202","line":""},
{"lineNum":"  203","line":"\t    // Used on reallocation to tell ASan unused capacity is invalid."},
{"lineNum":"  204","line":"\t    struct _Reinit"},
{"lineNum":"  205","line":"\t    {"},
{"lineNum":"  206","line":"\t      explicit _Reinit(_Vector_impl& __impl) : _M_impl(__impl)"},
{"lineNum":"  207","line":"\t      {"},
{"lineNum":"  208","line":"\t\t// Mark unused capacity as valid again before deallocating it."},
{"lineNum":"  209","line":"\t\t_S_on_dealloc(_M_impl);"},
{"lineNum":"  210","line":"\t      }"},
{"lineNum":"  211","line":""},
{"lineNum":"  212","line":"\t      ~_Reinit()"},
{"lineNum":"  213","line":"\t      {"},
{"lineNum":"  214","line":"\t\t// Mark unused capacity as invalid after reallocation."},
{"lineNum":"  215","line":"\t\tif (_M_impl._M_start)"},
{"lineNum":"  216","line":"\t\t  _S_adjust(_M_impl, _M_impl._M_end_of_storage,"},
{"lineNum":"  217","line":"\t\t\t    _M_impl._M_finish);"},
{"lineNum":"  218","line":"\t      }"},
{"lineNum":"  219","line":""},
{"lineNum":"  220","line":"\t      _Vector_impl& _M_impl;"},
{"lineNum":"  221","line":""},
{"lineNum":"  222","line":"#if __cplusplus >= 201103L"},
{"lineNum":"  223","line":"\t      _Reinit(const _Reinit&) = delete;"},
{"lineNum":"  224","line":"\t      _Reinit& operator=(const _Reinit&) = delete;"},
{"lineNum":"  225","line":"#endif"},
{"lineNum":"  226","line":"\t    };"},
{"lineNum":"  227","line":""},
{"lineNum":"  228","line":"\t    // Tell ASan when unused capacity is initialized to be valid."},
{"lineNum":"  229","line":"\t    struct _Grow"},
{"lineNum":"  230","line":"\t    {"},
{"lineNum":"  231","line":"\t      _Grow(_Vector_impl& __impl, size_type __n)"},
{"lineNum":"  232","line":"\t      : _M_impl(__impl), _M_n(__n)"},
{"lineNum":"  233","line":"\t      { _S_grow(_M_impl, __n); }"},
{"lineNum":"  234","line":""},
{"lineNum":"  235","line":"\t      ~_Grow() { if (_M_n) _S_shrink(_M_impl, _M_n); }"},
{"lineNum":"  236","line":""},
{"lineNum":"  237","line":"\t      void _M_grew(size_type __n) { _M_n -= __n; }"},
{"lineNum":"  238","line":""},
{"lineNum":"  239","line":"#if __cplusplus >= 201103L"},
{"lineNum":"  240","line":"\t      _Grow(const _Grow&) = delete;"},
{"lineNum":"  241","line":"\t      _Grow& operator=(const _Grow&) = delete;"},
{"lineNum":"  242","line":"#endif"},
{"lineNum":"  243","line":"\t    private:"},
{"lineNum":"  244","line":"\t      _Vector_impl& _M_impl;"},
{"lineNum":"  245","line":"\t      size_type _M_n;"},
{"lineNum":"  246","line":"\t    };"},
{"lineNum":"  247","line":"\t  };"},
{"lineNum":"  248","line":""},
{"lineNum":"  249","line":"#define _GLIBCXX_ASAN_ANNOTATE_REINIT \\"},
{"lineNum":"  250","line":"  typename _Base::_Vector_impl::template _Asan<>::_Reinit const \\"},
{"lineNum":"  251","line":"\t__attribute__((__unused__)) __reinit_guard(this->_M_impl)"},
{"lineNum":"  252","line":"#define _GLIBCXX_ASAN_ANNOTATE_GROW(n) \\"},
{"lineNum":"  253","line":"  typename _Base::_Vector_impl::template _Asan<>::_Grow \\"},
{"lineNum":"  254","line":"\t__attribute__((__unused__)) __grow_guard(this->_M_impl, (n))"},
{"lineNum":"  255","line":"#define _GLIBCXX_ASAN_ANNOTATE_GREW(n) __grow_guard._M_grew(n)"},
{"lineNum":"  256","line":"#define _GLIBCXX_ASAN_ANNOTATE_SHRINK(n) \\"},
{"lineNum":"  257","line":"  _Base::_Vector_impl::template _Asan<>::_S_shrink(this->_M_impl, n)"},
{"lineNum":"  258","line":"#define _GLIBCXX_ASAN_ANNOTATE_BEFORE_DEALLOC \\"},
{"lineNum":"  259","line":"  _Base::_Vector_impl::template _Asan<>::_S_on_dealloc(this->_M_impl)"},
{"lineNum":"  260","line":"#else // ! (_GLIBCXX_SANITIZE_STD_ALLOCATOR && _GLIBCXX_SANITIZE_VECTOR)"},
{"lineNum":"  261","line":"#define _GLIBCXX_ASAN_ANNOTATE_REINIT"},
{"lineNum":"  262","line":"#define _GLIBCXX_ASAN_ANNOTATE_GROW(n)"},
{"lineNum":"  263","line":"#define _GLIBCXX_ASAN_ANNOTATE_GREW(n)"},
{"lineNum":"  264","line":"#define _GLIBCXX_ASAN_ANNOTATE_SHRINK(n)"},
{"lineNum":"  265","line":"#define _GLIBCXX_ASAN_ANNOTATE_BEFORE_DEALLOC"},
{"lineNum":"  266","line":"#endif // _GLIBCXX_SANITIZE_STD_ALLOCATOR && _GLIBCXX_SANITIZE_VECTOR"},
{"lineNum":"  267","line":"      };"},
{"lineNum":"  268","line":""},
{"lineNum":"  269","line":"    public:"},
{"lineNum":"  270","line":"      typedef _Alloc allocator_type;"},
{"lineNum":"  271","line":""},
{"lineNum":"  272","line":"      _Tp_alloc_type&"},
{"lineNum":"  273","line":"      _M_get_Tp_allocator() _GLIBCXX_NOEXCEPT","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  274","line":"      { return this->_M_impl; }","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  275","line":""},
{"lineNum":"  276","line":"      const _Tp_alloc_type&"},
{"lineNum":"  277","line":"      _M_get_Tp_allocator() const _GLIBCXX_NOEXCEPT","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  278","line":"      { return this->_M_impl; }","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  279","line":""},
{"lineNum":"  280","line":"      allocator_type"},
{"lineNum":"  281","line":"      get_allocator() const _GLIBCXX_NOEXCEPT","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  282","line":"      { return allocator_type(_M_get_Tp_allocator()); }","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  283","line":""},
{"lineNum":"  284","line":"#if __cplusplus >= 201103L"},
{"lineNum":"  285","line":"      _Vector_base() = default;","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  286","line":"#else"},
{"lineNum":"  287","line":"      _Vector_base() { }"},
{"lineNum":"  288","line":"#endif"},
{"lineNum":"  289","line":""},
{"lineNum":"  290","line":"      _Vector_base(const allocator_type& __a) _GLIBCXX_NOEXCEPT","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  291","line":"      : _M_impl(__a) { }","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  292","line":""},
{"lineNum":"  293","line":"      // Kept for ABI compatibility."},
{"lineNum":"  294","line":"#if !_GLIBCXX_INLINE_VERSION"},
{"lineNum":"  295","line":"      _Vector_base(size_t __n)"},
{"lineNum":"  296","line":"      : _M_impl()"},
{"lineNum":"  297","line":"      { _M_create_storage(__n); }"},
{"lineNum":"  298","line":"#endif"},
{"lineNum":"  299","line":""},
{"lineNum":"  300","line":"      _Vector_base(size_t __n, const allocator_type& __a)","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  301","line":"      : _M_impl(__a)","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  302","line":"      { _M_create_storage(__n); }","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  303","line":""},
{"lineNum":"  304","line":"#if __cplusplus >= 201103L"},
{"lineNum":"  305","line":"      _Vector_base(_Vector_base&&) = default;","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  306","line":""},
{"lineNum":"  307","line":"      // Kept for ABI compatibility."},
{"lineNum":"  308","line":"# if !_GLIBCXX_INLINE_VERSION"},
{"lineNum":"  309","line":"      _Vector_base(_Tp_alloc_type&& __a) noexcept"},
{"lineNum":"  310","line":"      : _M_impl(std::move(__a)) { }"},
{"lineNum":"  311","line":""},
{"lineNum":"  312","line":"      _Vector_base(_Vector_base&& __x, const allocator_type& __a)"},
{"lineNum":"  313","line":"      : _M_impl(__a)"},
{"lineNum":"  314","line":"      {"},
{"lineNum":"  315","line":"\tif (__x.get_allocator() == __a)"},
{"lineNum":"  316","line":"\t  this->_M_impl._M_swap_data(__x._M_impl);"},
{"lineNum":"  317","line":"\telse"},
{"lineNum":"  318","line":"\t  {"},
{"lineNum":"  319","line":"\t    size_t __n = __x._M_impl._M_finish - __x._M_impl._M_start;"},
{"lineNum":"  320","line":"\t    _M_create_storage(__n);"},
{"lineNum":"  321","line":"\t  }"},
{"lineNum":"  322","line":"      }"},
{"lineNum":"  323","line":"# endif"},
{"lineNum":"  324","line":""},
{"lineNum":"  325","line":"      _Vector_base(const allocator_type& __a, _Vector_base&& __x)"},
{"lineNum":"  326","line":"      : _M_impl(_Tp_alloc_type(__a), std::move(__x._M_impl))"},
{"lineNum":"  327","line":"      { }"},
{"lineNum":"  328","line":"#endif"},
{"lineNum":"  329","line":""},
{"lineNum":"  330","line":"      ~_Vector_base() _GLIBCXX_NOEXCEPT","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  331","line":"      {"},
{"lineNum":"  332","line":"\t_M_deallocate(_M_impl._M_start,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  333","line":"\t\t      _M_impl._M_end_of_storage - _M_impl._M_start);","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  334","line":"      }","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  335","line":""},
{"lineNum":"  336","line":"    public:"},
{"lineNum":"  337","line":"      _Vector_impl _M_impl;"},
{"lineNum":"  338","line":""},
{"lineNum":"  339","line":"      pointer"},
{"lineNum":"  340","line":"      _M_allocate(size_t __n)","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  341","line":"      {"},
{"lineNum":"  342","line":"\ttypedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;"},
{"lineNum":"  343","line":"\treturn __n != 0 ? _Tr::allocate(_M_impl, __n) : pointer();","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":"  344","line":"      }","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  345","line":""},
{"lineNum":"  346","line":"      void"},
{"lineNum":"  347","line":"      _M_deallocate(pointer __p, size_t __n)","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  348","line":"      {"},
{"lineNum":"  349","line":"\ttypedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;"},
{"lineNum":"  350","line":"\tif (__p)","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  351","line":"\t  _Tr::deallocate(_M_impl, __p, __n);","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  352","line":"      }","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  353","line":""},
{"lineNum":"  354","line":"    protected:"},
{"lineNum":"  355","line":"      void"},
{"lineNum":"  356","line":"      _M_create_storage(size_t __n)","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  357","line":"      {"},
{"lineNum":"  358","line":"\tthis->_M_impl._M_start = this->_M_allocate(__n);","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  359","line":"\tthis->_M_impl._M_finish = this->_M_impl._M_start;","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  360","line":"\tthis->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  361","line":"      }","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  362","line":"    };"},
{"lineNum":"  363","line":""},
{"lineNum":"  364","line":"  /**"},
{"lineNum":"  365","line":"   *  @brief A standard container which offers fixed time access to"},
{"lineNum":"  366","line":"   *  individual elements in any order."},
{"lineNum":"  367","line":"   *"},
{"lineNum":"  368","line":"   *  @ingroup sequences"},
{"lineNum":"  369","line":"   *"},
{"lineNum":"  370","line":"   *  @tparam _Tp  Type of element."},
{"lineNum":"  371","line":"   *  @tparam _Alloc  Allocator type, defaults to allocator<_Tp>."},
{"lineNum":"  372","line":"   *"},
{"lineNum":"  373","line":"   *  Meets the requirements of a <a href=\"tables.html#65\">container</a>, a"},
{"lineNum":"  374","line":"   *  <a href=\"tables.html#66\">reversible container</a>, and a"},
{"lineNum":"  375","line":"   *  <a href=\"tables.html#67\">sequence</a>, including the"},
{"lineNum":"  376","line":"   *  <a href=\"tables.html#68\">optional sequence requirements</a> with the"},
{"lineNum":"  377","line":"   *  %exception of @c push_front and @c pop_front."},
{"lineNum":"  378","line":"   *"},
{"lineNum":"  379","line":"   *  In some terminology a %vector can be described as a dynamic"},
{"lineNum":"  380","line":"   *  C-style array, it offers fast and efficient access to individual"},
{"lineNum":"  381","line":"   *  elements in any order and saves the user from worrying about"},
{"lineNum":"  382","line":"   *  memory and size allocation.  Subscripting ( @c [] ) access is"},
{"lineNum":"  383","line":"   *  also provided as with C-style arrays."},
{"lineNum":"  384","line":"  */"},
{"lineNum":"  385","line":"  template<typename _Tp, typename _Alloc = std::allocator<_Tp> >"},
{"lineNum":"  386","line":"    class vector : protected _Vector_base<_Tp, _Alloc>"},
{"lineNum":"  387","line":"    {"},
{"lineNum":"  388","line":"#ifdef _GLIBCXX_CONCEPT_CHECKS"},
{"lineNum":"  389","line":"      // Concept requirements."},
{"lineNum":"  390","line":"      typedef typename _Alloc::value_type\t\t_Alloc_value_type;"},
{"lineNum":"  391","line":"# if __cplusplus < 201103L"},
{"lineNum":"  392","line":"      __glibcxx_class_requires(_Tp, _SGIAssignableConcept)"},
{"lineNum":"  393","line":"# endif"},
{"lineNum":"  394","line":"      __glibcxx_class_requires2(_Tp, _Alloc_value_type, _SameTypeConcept)"},
{"lineNum":"  395","line":"#endif"},
{"lineNum":"  396","line":""},
{"lineNum":"  397","line":"#if __cplusplus >= 201103L"},
{"lineNum":"  398","line":"      static_assert(is_same<typename remove_cv<_Tp>::type, _Tp>::value,"},
{"lineNum":"  399","line":"\t  \"std::vector must have a non-const, non-volatile value_type\");"},
{"lineNum":"  400","line":"# ifdef __STRICT_ANSI__"},
{"lineNum":"  401","line":"      static_assert(is_same<typename _Alloc::value_type, _Tp>::value,"},
{"lineNum":"  402","line":"\t  \"std::vector must have the same value_type as its allocator\");"},
{"lineNum":"  403","line":"# endif"},
{"lineNum":"  404","line":"#endif"},
{"lineNum":"  405","line":""},
{"lineNum":"  406","line":"      typedef _Vector_base<_Tp, _Alloc>\t\t\t_Base;"},
{"lineNum":"  407","line":"      typedef typename _Base::_Tp_alloc_type\t\t_Tp_alloc_type;"},
{"lineNum":"  408","line":"      typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type>\t_Alloc_traits;"},
{"lineNum":"  409","line":""},
{"lineNum":"  410","line":"    public:"},
{"lineNum":"  411","line":"      typedef _Tp\t\t\t\t\tvalue_type;"},
{"lineNum":"  412","line":"      typedef typename _Base::pointer\t\t\tpointer;"},
{"lineNum":"  413","line":"      typedef typename _Alloc_traits::const_pointer\tconst_pointer;"},
{"lineNum":"  414","line":"      typedef typename _Alloc_traits::reference\t\treference;"},
{"lineNum":"  415","line":"      typedef typename _Alloc_traits::const_reference\tconst_reference;"},
{"lineNum":"  416","line":"      typedef __gnu_cxx::__normal_iterator<pointer, vector> iterator;"},
{"lineNum":"  417","line":"      typedef __gnu_cxx::__normal_iterator<const_pointer, vector>"},
{"lineNum":"  418","line":"      const_iterator;"},
{"lineNum":"  419","line":"      typedef std::reverse_iterator<const_iterator>\tconst_reverse_iterator;"},
{"lineNum":"  420","line":"      typedef std::reverse_iterator<iterator>\t\treverse_iterator;"},
{"lineNum":"  421","line":"      typedef size_t\t\t\t\t\tsize_type;"},
{"lineNum":"  422","line":"      typedef ptrdiff_t\t\t\t\t\tdifference_type;"},
{"lineNum":"  423","line":"      typedef _Alloc\t\t\t\t\tallocator_type;"},
{"lineNum":"  424","line":""},
{"lineNum":"  425","line":"    private:"},
{"lineNum":"  426","line":"#if __cplusplus >= 201103L"},
{"lineNum":"  427","line":"      static constexpr bool"},
{"lineNum":"  428","line":"      _S_nothrow_relocate(true_type)","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  429","line":"      {"},
{"lineNum":"  430","line":"\treturn noexcept(std::__relocate_a(std::declval<pointer>(),"},
{"lineNum":"  431","line":"\t\t\t\t\t  std::declval<pointer>(),"},
{"lineNum":"  432","line":"\t\t\t\t\t  std::declval<pointer>(),"},
{"lineNum":"  433","line":"\t\t\t\t\t  std::declval<_Tp_alloc_type&>()));","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  434","line":"      }","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  435","line":""},
{"lineNum":"  436","line":"      static constexpr bool"},
{"lineNum":"  437","line":"      _S_nothrow_relocate(false_type)"},
{"lineNum":"  438","line":"      { return false; }"},
{"lineNum":"  439","line":""},
{"lineNum":"  440","line":"      static constexpr bool"},
{"lineNum":"  441","line":"      _S_use_relocate()","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  442","line":"      {"},
{"lineNum":"  443","line":"\t// Instantiating std::__relocate_a might cause an error outside the"},
{"lineNum":"  444","line":"\t// immediate context (in __relocate_object_a\'s noexcept-specifier),"},
{"lineNum":"  445","line":"\t// so only do it if we know the type can be move-inserted into *this."},
{"lineNum":"  446","line":"\treturn _S_nothrow_relocate(__is_move_insertable<_Tp_alloc_type>{});","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  447","line":"      }","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  448","line":""},
{"lineNum":"  449","line":"      static pointer"},
{"lineNum":"  450","line":"      _S_do_relocate(pointer __first, pointer __last, pointer __result,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  451","line":"\t\t     _Tp_alloc_type& __alloc, true_type) noexcept"},
{"lineNum":"  452","line":"      {"},
{"lineNum":"  453","line":"\treturn std::__relocate_a(__first, __last, __result, __alloc);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  454","line":"      }","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  455","line":""},
{"lineNum":"  456","line":"      static pointer"},
{"lineNum":"  457","line":"      _S_do_relocate(pointer, pointer, pointer __result,"},
{"lineNum":"  458","line":"\t\t     _Tp_alloc_type&, false_type) noexcept"},
{"lineNum":"  459","line":"      { return __result; }"},
{"lineNum":"  460","line":""},
{"lineNum":"  461","line":"      static pointer"},
{"lineNum":"  462","line":"      _S_relocate(pointer __first, pointer __last, pointer __result,","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  463","line":"\t\t  _Tp_alloc_type& __alloc) noexcept"},
{"lineNum":"  464","line":"      {"},
{"lineNum":"  465","line":"\tusing __do_it = __bool_constant<_S_use_relocate()>;"},
{"lineNum":"  466","line":"\treturn _S_do_relocate(__first, __last, __result, __alloc, __do_it{});","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  467","line":"      }","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  468","line":"#endif // C++11"},
{"lineNum":"  469","line":""},
{"lineNum":"  470","line":"    protected:"},
{"lineNum":"  471","line":"      using _Base::_M_allocate;"},
{"lineNum":"  472","line":"      using _Base::_M_deallocate;"},
{"lineNum":"  473","line":"      using _Base::_M_impl;"},
{"lineNum":"  474","line":"      using _Base::_M_get_Tp_allocator;"},
{"lineNum":"  475","line":""},
{"lineNum":"  476","line":"    public:"},
{"lineNum":"  477","line":"      // [23.2.4.1] construct/copy/destroy"},
{"lineNum":"  478","line":"      // (assign() and get_allocator() are also listed in this section)"},
{"lineNum":"  479","line":""},
{"lineNum":"  480","line":"      /**"},
{"lineNum":"  481","line":"       *  @brief  Creates a %vector with no elements."},
{"lineNum":"  482","line":"       */"},
{"lineNum":"  483","line":"#if __cplusplus >= 201103L"},
{"lineNum":"  484","line":"      vector() = default;","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  485","line":"#else"},
{"lineNum":"  486","line":"      vector() { }"},
{"lineNum":"  487","line":"#endif"},
{"lineNum":"  488","line":""},
{"lineNum":"  489","line":"      /**"},
{"lineNum":"  490","line":"       *  @brief  Creates a %vector with no elements."},
{"lineNum":"  491","line":"       *  @param  __a  An allocator object."},
{"lineNum":"  492","line":"       */"},
{"lineNum":"  493","line":"      explicit"},
{"lineNum":"  494","line":"      vector(const allocator_type& __a) _GLIBCXX_NOEXCEPT"},
{"lineNum":"  495","line":"      : _Base(__a) { }"},
{"lineNum":"  496","line":""},
{"lineNum":"  497","line":"#if __cplusplus >= 201103L"},
{"lineNum":"  498","line":"      /**"},
{"lineNum":"  499","line":"       *  @brief  Creates a %vector with default constructed elements."},
{"lineNum":"  500","line":"       *  @param  __n  The number of elements to initially create."},
{"lineNum":"  501","line":"       *  @param  __a  An allocator."},
{"lineNum":"  502","line":"       *"},
{"lineNum":"  503","line":"       *  This constructor fills the %vector with @a __n default"},
{"lineNum":"  504","line":"       *  constructed elements."},
{"lineNum":"  505","line":"       */"},
{"lineNum":"  506","line":"      explicit"},
{"lineNum":"  507","line":"      vector(size_type __n, const allocator_type& __a = allocator_type())","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  508","line":"      : _Base(_S_check_init_len(__n, __a), __a)","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  509","line":"      { _M_default_initialize(__n); }","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  510","line":""},
{"lineNum":"  511","line":"      /**"},
{"lineNum":"  512","line":"       *  @brief  Creates a %vector with copies of an exemplar element."},
{"lineNum":"  513","line":"       *  @param  __n  The number of elements to initially create."},
{"lineNum":"  514","line":"       *  @param  __value  An element to copy."},
{"lineNum":"  515","line":"       *  @param  __a  An allocator."},
{"lineNum":"  516","line":"       *"},
{"lineNum":"  517","line":"       *  This constructor fills the %vector with @a __n copies of @a __value."},
{"lineNum":"  518","line":"       */"},
{"lineNum":"  519","line":"      vector(size_type __n, const value_type& __value,"},
{"lineNum":"  520","line":"\t     const allocator_type& __a = allocator_type())"},
{"lineNum":"  521","line":"      : _Base(_S_check_init_len(__n, __a), __a)"},
{"lineNum":"  522","line":"      { _M_fill_initialize(__n, __value); }"},
{"lineNum":"  523","line":"#else"},
{"lineNum":"  524","line":"      /**"},
{"lineNum":"  525","line":"       *  @brief  Creates a %vector with copies of an exemplar element."},
{"lineNum":"  526","line":"       *  @param  __n  The number of elements to initially create."},
{"lineNum":"  527","line":"       *  @param  __value  An element to copy."},
{"lineNum":"  528","line":"       *  @param  __a  An allocator."},
{"lineNum":"  529","line":"       *"},
{"lineNum":"  530","line":"       *  This constructor fills the %vector with @a __n copies of @a __value."},
{"lineNum":"  531","line":"       */"},
{"lineNum":"  532","line":"      explicit"},
{"lineNum":"  533","line":"      vector(size_type __n, const value_type& __value = value_type(),"},
{"lineNum":"  534","line":"\t     const allocator_type& __a = allocator_type())"},
{"lineNum":"  535","line":"      : _Base(_S_check_init_len(__n, __a), __a)"},
{"lineNum":"  536","line":"      { _M_fill_initialize(__n, __value); }"},
{"lineNum":"  537","line":"#endif"},
{"lineNum":"  538","line":""},
{"lineNum":"  539","line":"      /**"},
{"lineNum":"  540","line":"       *  @brief  %Vector copy constructor."},
{"lineNum":"  541","line":"       *  @param  __x  A %vector of identical element and allocator types."},
{"lineNum":"  542","line":"       *"},
{"lineNum":"  543","line":"       *  All the elements of @a __x are copied, but any unused capacity in"},
{"lineNum":"  544","line":"       *  @a __x  will not be copied"},
{"lineNum":"  545","line":"       *  (i.e. capacity() == size() in the new %vector)."},
{"lineNum":"  546","line":"       *"},
{"lineNum":"  547","line":"       *  The newly-created %vector uses a copy of the allocator object used"},
{"lineNum":"  548","line":"       *  by @a __x (unless the allocator traits dictate a different object)."},
{"lineNum":"  549","line":"       */"},
{"lineNum":"  550","line":"      vector(const vector& __x)","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  551","line":"      : _Base(__x.size(),"},
{"lineNum":"  552","line":"\t_Alloc_traits::_S_select_on_copy(__x._M_get_Tp_allocator()))","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  553","line":"      {"},
{"lineNum":"  554","line":"\tthis->_M_impl._M_finish =","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  555","line":"\t  std::__uninitialized_copy_a(__x.begin(), __x.end(),","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  556","line":"\t\t\t\t      this->_M_impl._M_start,"},
{"lineNum":"  557","line":"\t\t\t\t      _M_get_Tp_allocator());","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  558","line":"      }","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  559","line":""},
{"lineNum":"  560","line":"#if __cplusplus >= 201103L"},
{"lineNum":"  561","line":"      /**"},
{"lineNum":"  562","line":"       *  @brief  %Vector move constructor."},
{"lineNum":"  563","line":"       *"},
{"lineNum":"  564","line":"       *  The newly-created %vector contains the exact contents of the"},
{"lineNum":"  565","line":"       *  moved instance."},
{"lineNum":"  566","line":"       *  The contents of the moved instance are a valid, but unspecified"},
{"lineNum":"  567","line":"       *  %vector."},
{"lineNum":"  568","line":"       */"},
{"lineNum":"  569","line":"      vector(vector&&) noexcept = default;","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  570","line":""},
{"lineNum":"  571","line":"      /// Copy constructor with alternative allocator"},
{"lineNum":"  572","line":"      vector(const vector& __x, const allocator_type& __a)"},
{"lineNum":"  573","line":"      : _Base(__x.size(), __a)"},
{"lineNum":"  574","line":"      {"},
{"lineNum":"  575","line":"\tthis->_M_impl._M_finish ="},
{"lineNum":"  576","line":"\t  std::__uninitialized_copy_a(__x.begin(), __x.end(),"},
{"lineNum":"  577","line":"\t\t\t\t      this->_M_impl._M_start,"},
{"lineNum":"  578","line":"\t\t\t\t      _M_get_Tp_allocator());"},
{"lineNum":"  579","line":"      }"},
{"lineNum":"  580","line":""},
{"lineNum":"  581","line":"    private:"},
{"lineNum":"  582","line":"      vector(vector&& __rv, const allocator_type& __m, true_type) noexcept"},
{"lineNum":"  583","line":"      : _Base(__m, std::move(__rv))"},
{"lineNum":"  584","line":"      { }"},
{"lineNum":"  585","line":""},
{"lineNum":"  586","line":"      vector(vector&& __rv, const allocator_type& __m, false_type)"},
{"lineNum":"  587","line":"      : _Base(__m)"},
{"lineNum":"  588","line":"      {"},
{"lineNum":"  589","line":"\tif (__rv.get_allocator() == __m)"},
{"lineNum":"  590","line":"\t  this->_M_impl._M_swap_data(__rv._M_impl);"},
{"lineNum":"  591","line":"\telse if (!__rv.empty())"},
{"lineNum":"  592","line":"\t  {"},
{"lineNum":"  593","line":"\t    this->_M_create_storage(__rv.size());"},
{"lineNum":"  594","line":"\t    this->_M_impl._M_finish ="},
{"lineNum":"  595","line":"\t      std::__uninitialized_move_a(__rv.begin(), __rv.end(),"},
{"lineNum":"  596","line":"\t\t\t\t\t  this->_M_impl._M_start,"},
{"lineNum":"  597","line":"\t\t\t\t\t  _M_get_Tp_allocator());"},
{"lineNum":"  598","line":"\t    __rv.clear();"},
{"lineNum":"  599","line":"\t  }"},
{"lineNum":"  600","line":"      }"},
{"lineNum":"  601","line":""},
{"lineNum":"  602","line":"    public:"},
{"lineNum":"  603","line":"      /// Move constructor with alternative allocator"},
{"lineNum":"  604","line":"      vector(vector&& __rv, const allocator_type& __m)"},
{"lineNum":"  605","line":"      noexcept( noexcept("},
{"lineNum":"  606","line":"\tvector(std::declval<vector&&>(), std::declval<const allocator_type&>(),"},
{"lineNum":"  607","line":"\t       std::declval<typename _Alloc_traits::is_always_equal>())) )"},
{"lineNum":"  608","line":"      : vector(std::move(__rv), __m, typename _Alloc_traits::is_always_equal{})"},
{"lineNum":"  609","line":"      { }"},
{"lineNum":"  610","line":""},
{"lineNum":"  611","line":"      /**"},
{"lineNum":"  612","line":"       *  @brief  Builds a %vector from an initializer list."},
{"lineNum":"  613","line":"       *  @param  __l  An initializer_list."},
{"lineNum":"  614","line":"       *  @param  __a  An allocator."},
{"lineNum":"  615","line":"       *"},
{"lineNum":"  616","line":"       *  Create a %vector consisting of copies of the elements in the"},
{"lineNum":"  617","line":"       *  initializer_list @a __l."},
{"lineNum":"  618","line":"       *"},
{"lineNum":"  619","line":"       *  This will call the element type\'s copy constructor N times"},
{"lineNum":"  620","line":"       *  (where N is @a __l.size()) and do no memory reallocation."},
{"lineNum":"  621","line":"       */"},
{"lineNum":"  622","line":"      vector(initializer_list<value_type> __l,"},
{"lineNum":"  623","line":"\t     const allocator_type& __a = allocator_type())"},
{"lineNum":"  624","line":"      : _Base(__a)"},
{"lineNum":"  625","line":"      {"},
{"lineNum":"  626","line":"\t_M_range_initialize(__l.begin(), __l.end(),"},
{"lineNum":"  627","line":"\t\t\t    random_access_iterator_tag());"},
{"lineNum":"  628","line":"      }"},
{"lineNum":"  629","line":"#endif"},
{"lineNum":"  630","line":""},
{"lineNum":"  631","line":"      /**"},
{"lineNum":"  632","line":"       *  @brief  Builds a %vector from a range."},
{"lineNum":"  633","line":"       *  @param  __first  An input iterator."},
{"lineNum":"  634","line":"       *  @param  __last  An input iterator."},
{"lineNum":"  635","line":"       *  @param  __a  An allocator."},
{"lineNum":"  636","line":"       *"},
{"lineNum":"  637","line":"       *  Create a %vector consisting of copies of the elements from"},
{"lineNum":"  638","line":"       *  [first,last)."},
{"lineNum":"  639","line":"       *"},
{"lineNum":"  640","line":"       *  If the iterators are forward, bidirectional, or"},
{"lineNum":"  641","line":"       *  random-access, then this will call the elements\' copy"},
{"lineNum":"  642","line":"       *  constructor N times (where N is distance(first,last)) and do"},
{"lineNum":"  643","line":"       *  no memory reallocation.  But if only input iterators are"},
{"lineNum":"  644","line":"       *  used, then this will do at most 2N calls to the copy"},
{"lineNum":"  645","line":"       *  constructor, and logN memory reallocations."},
{"lineNum":"  646","line":"       */"},
{"lineNum":"  647","line":"#if __cplusplus >= 201103L"},
{"lineNum":"  648","line":"      template<typename _InputIterator,"},
{"lineNum":"  649","line":"\t       typename = std::_RequireInputIter<_InputIterator>>"},
{"lineNum":"  650","line":"\tvector(_InputIterator __first, _InputIterator __last,","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  651","line":"\t       const allocator_type& __a = allocator_type())"},
{"lineNum":"  652","line":"\t: _Base(__a)","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  653","line":"\t{"},
{"lineNum":"  654","line":"\t  _M_range_initialize(__first, __last,","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  655","line":"\t\t\t      std::__iterator_category(__first));","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  656","line":"\t}","class":"lineNoCov","hits":"0","possible_hits":"6",},
{"lineNum":"  657","line":"#else"},
{"lineNum":"  658","line":"      template<typename _InputIterator>"},
{"lineNum":"  659","line":"\tvector(_InputIterator __first, _InputIterator __last,"},
{"lineNum":"  660","line":"\t       const allocator_type& __a = allocator_type())"},
{"lineNum":"  661","line":"\t: _Base(__a)"},
{"lineNum":"  662","line":"\t{"},
{"lineNum":"  663","line":"\t  // Check whether it\'s an integral type.  If so, it\'s not an iterator."},
{"lineNum":"  664","line":"\t  typedef typename std::__is_integer<_InputIterator>::__type _Integral;"},
{"lineNum":"  665","line":"\t  _M_initialize_dispatch(__first, __last, _Integral());"},
{"lineNum":"  666","line":"\t}"},
{"lineNum":"  667","line":"#endif"},
{"lineNum":"  668","line":""},
{"lineNum":"  669","line":"      /**"},
{"lineNum":"  670","line":"       *  The dtor only erases the elements, and note that if the"},
{"lineNum":"  671","line":"       *  elements themselves are pointers, the pointed-to memory is"},
{"lineNum":"  672","line":"       *  not touched in any way.  Managing the pointer is the user\'s"},
{"lineNum":"  673","line":"       *  responsibility."},
{"lineNum":"  674","line":"       */"},
{"lineNum":"  675","line":"      ~vector() _GLIBCXX_NOEXCEPT","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  676","line":"      {"},
{"lineNum":"  677","line":"\tstd::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  678","line":"\t\t      _M_get_Tp_allocator());","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  679","line":"\t_GLIBCXX_ASAN_ANNOTATE_BEFORE_DEALLOC;"},
{"lineNum":"  680","line":"      }","class":"linePartCov","hits":"1","order":"90","possible_hits":"2",},
{"lineNum":"  681","line":""},
{"lineNum":"  682","line":"      /**"},
{"lineNum":"  683","line":"       *  @brief  %Vector assignment operator."},
{"lineNum":"  684","line":"       *  @param  __x  A %vector of identical element and allocator types."},
{"lineNum":"  685","line":"       *"},
{"lineNum":"  686","line":"       *  All the elements of @a __x are copied, but any unused capacity in"},
{"lineNum":"  687","line":"       *  @a __x will not be copied."},
{"lineNum":"  688","line":"       *"},
{"lineNum":"  689","line":"       *  Whether the allocator is copied depends on the allocator traits."},
{"lineNum":"  690","line":"       */"},
{"lineNum":"  691","line":"      vector&"},
{"lineNum":"  692","line":"      operator=(const vector& __x);"},
{"lineNum":"  693","line":""},
{"lineNum":"  694","line":"#if __cplusplus >= 201103L"},
{"lineNum":"  695","line":"      /**"},
{"lineNum":"  696","line":"       *  @brief  %Vector move assignment operator."},
{"lineNum":"  697","line":"       *  @param  __x  A %vector of identical element and allocator types."},
{"lineNum":"  698","line":"       *"},
{"lineNum":"  699","line":"       *  The contents of @a __x are moved into this %vector (without copying,"},
{"lineNum":"  700","line":"       *  if the allocators permit it)."},
{"lineNum":"  701","line":"       *  Afterwards @a __x is a valid, but unspecified %vector."},
{"lineNum":"  702","line":"       *"},
{"lineNum":"  703","line":"       *  Whether the allocator is moved depends on the allocator traits."},
{"lineNum":"  704","line":"       */"},
{"lineNum":"  705","line":"      vector&"},
{"lineNum":"  706","line":"      operator=(vector&& __x) noexcept(_Alloc_traits::_S_nothrow_move())"},
{"lineNum":"  707","line":"      {"},
{"lineNum":"  708","line":"\tconstexpr bool __move_storage ="},
{"lineNum":"  709","line":"\t  _Alloc_traits::_S_propagate_on_move_assign()"},
{"lineNum":"  710","line":"\t  || _Alloc_traits::_S_always_equal();"},
{"lineNum":"  711","line":"\t_M_move_assign(std::move(__x), __bool_constant<__move_storage>());"},
{"lineNum":"  712","line":"\treturn *this;"},
{"lineNum":"  713","line":"      }"},
{"lineNum":"  714","line":""},
{"lineNum":"  715","line":"      /**"},
{"lineNum":"  716","line":"       *  @brief  %Vector list assignment operator."},
{"lineNum":"  717","line":"       *  @param  __l  An initializer_list."},
{"lineNum":"  718","line":"       *"},
{"lineNum":"  719","line":"       *  This function fills a %vector with copies of the elements in the"},
{"lineNum":"  720","line":"       *  initializer list @a __l."},
{"lineNum":"  721","line":"       *"},
{"lineNum":"  722","line":"       *  Note that the assignment completely changes the %vector and"},
{"lineNum":"  723","line":"       *  that the resulting %vector\'s size is the same as the number"},
{"lineNum":"  724","line":"       *  of elements assigned."},
{"lineNum":"  725","line":"       */"},
{"lineNum":"  726","line":"      vector&"},
{"lineNum":"  727","line":"      operator=(initializer_list<value_type> __l)"},
{"lineNum":"  728","line":"      {"},
{"lineNum":"  729","line":"\tthis->_M_assign_aux(__l.begin(), __l.end(),"},
{"lineNum":"  730","line":"\t\t\t    random_access_iterator_tag());"},
{"lineNum":"  731","line":"\treturn *this;"},
{"lineNum":"  732","line":"      }"},
{"lineNum":"  733","line":"#endif"},
{"lineNum":"  734","line":""},
{"lineNum":"  735","line":"      /**"},
{"lineNum":"  736","line":"       *  @brief  Assigns a given value to a %vector."},
{"lineNum":"  737","line":"       *  @param  __n  Number of elements to be assigned."},
{"lineNum":"  738","line":"       *  @param  __val  Value to be assigned."},
{"lineNum":"  739","line":"       *"},
{"lineNum":"  740","line":"       *  This function fills a %vector with @a __n copies of the given"},
{"lineNum":"  741","line":"       *  value.  Note that the assignment completely changes the"},
{"lineNum":"  742","line":"       *  %vector and that the resulting %vector\'s size is the same as"},
{"lineNum":"  743","line":"       *  the number of elements assigned."},
{"lineNum":"  744","line":"       */"},
{"lineNum":"  745","line":"      void"},
{"lineNum":"  746","line":"      assign(size_type __n, const value_type& __val)"},
{"lineNum":"  747","line":"      { _M_fill_assign(__n, __val); }"},
{"lineNum":"  748","line":""},
{"lineNum":"  749","line":"      /**"},
{"lineNum":"  750","line":"       *  @brief  Assigns a range to a %vector."},
{"lineNum":"  751","line":"       *  @param  __first  An input iterator."},
{"lineNum":"  752","line":"       *  @param  __last   An input iterator."},
{"lineNum":"  753","line":"       *"},
{"lineNum":"  754","line":"       *  This function fills a %vector with copies of the elements in the"},
{"lineNum":"  755","line":"       *  range [__first,__last)."},
{"lineNum":"  756","line":"       *"},
{"lineNum":"  757","line":"       *  Note that the assignment completely changes the %vector and"},
{"lineNum":"  758","line":"       *  that the resulting %vector\'s size is the same as the number"},
{"lineNum":"  759","line":"       *  of elements assigned."},
{"lineNum":"  760","line":"       */"},
{"lineNum":"  761","line":"#if __cplusplus >= 201103L"},
{"lineNum":"  762","line":"      template<typename _InputIterator,"},
{"lineNum":"  763","line":"\t       typename = std::_RequireInputIter<_InputIterator>>"},
{"lineNum":"  764","line":"\tvoid"},
{"lineNum":"  765","line":"\tassign(_InputIterator __first, _InputIterator __last)"},
{"lineNum":"  766","line":"\t{ _M_assign_dispatch(__first, __last, __false_type()); }"},
{"lineNum":"  767","line":"#else"},
{"lineNum":"  768","line":"      template<typename _InputIterator>"},
{"lineNum":"  769","line":"\tvoid"},
{"lineNum":"  770","line":"\tassign(_InputIterator __first, _InputIterator __last)"},
{"lineNum":"  771","line":"\t{"},
{"lineNum":"  772","line":"\t  // Check whether it\'s an integral type.  If so, it\'s not an iterator."},
{"lineNum":"  773","line":"\t  typedef typename std::__is_integer<_InputIterator>::__type _Integral;"},
{"lineNum":"  774","line":"\t  _M_assign_dispatch(__first, __last, _Integral());"},
{"lineNum":"  775","line":"\t}"},
{"lineNum":"  776","line":"#endif"},
{"lineNum":"  777","line":""},
{"lineNum":"  778","line":"#if __cplusplus >= 201103L"},
{"lineNum":"  779","line":"      /**"},
{"lineNum":"  780","line":"       *  @brief  Assigns an initializer list to a %vector."},
{"lineNum":"  781","line":"       *  @param  __l  An initializer_list."},
{"lineNum":"  782","line":"       *"},
{"lineNum":"  783","line":"       *  This function fills a %vector with copies of the elements in the"},
{"lineNum":"  784","line":"       *  initializer list @a __l."},
{"lineNum":"  785","line":"       *"},
{"lineNum":"  786","line":"       *  Note that the assignment completely changes the %vector and"},
{"lineNum":"  787","line":"       *  that the resulting %vector\'s size is the same as the number"},
{"lineNum":"  788","line":"       *  of elements assigned."},
{"lineNum":"  789","line":"       */"},
{"lineNum":"  790","line":"      void"},
{"lineNum":"  791","line":"      assign(initializer_list<value_type> __l)"},
{"lineNum":"  792","line":"      {"},
{"lineNum":"  793","line":"\tthis->_M_assign_aux(__l.begin(), __l.end(),"},
{"lineNum":"  794","line":"\t\t\t    random_access_iterator_tag());"},
{"lineNum":"  795","line":"      }"},
{"lineNum":"  796","line":"#endif"},
{"lineNum":"  797","line":""},
{"lineNum":"  798","line":"      /// Get a copy of the memory allocation object."},
{"lineNum":"  799","line":"      using _Base::get_allocator;"},
{"lineNum":"  800","line":""},
{"lineNum":"  801","line":"      // iterators"},
{"lineNum":"  802","line":"      /**"},
{"lineNum":"  803","line":"       *  Returns a read/write iterator that points to the first"},
{"lineNum":"  804","line":"       *  element in the %vector.  Iteration is done in ordinary"},
{"lineNum":"  805","line":"       *  element order."},
{"lineNum":"  806","line":"       */"},
{"lineNum":"  807","line":"      iterator"},
{"lineNum":"  808","line":"      begin() _GLIBCXX_NOEXCEPT","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  809","line":"      { return iterator(this->_M_impl._M_start); }","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  810","line":""},
{"lineNum":"  811","line":"      /**"},
{"lineNum":"  812","line":"       *  Returns a read-only (constant) iterator that points to the"},
{"lineNum":"  813","line":"       *  first element in the %vector.  Iteration is done in ordinary"},
{"lineNum":"  814","line":"       *  element order."},
{"lineNum":"  815","line":"       */"},
{"lineNum":"  816","line":"      const_iterator"},
{"lineNum":"  817","line":"      begin() const _GLIBCXX_NOEXCEPT","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  818","line":"      { return const_iterator(this->_M_impl._M_start); }","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  819","line":""},
{"lineNum":"  820","line":"      /**"},
{"lineNum":"  821","line":"       *  Returns a read/write iterator that points one past the last"},
{"lineNum":"  822","line":"       *  element in the %vector.  Iteration is done in ordinary"},
{"lineNum":"  823","line":"       *  element order."},
{"lineNum":"  824","line":"       */"},
{"lineNum":"  825","line":"      iterator"},
{"lineNum":"  826","line":"      end() _GLIBCXX_NOEXCEPT","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  827","line":"      { return iterator(this->_M_impl._M_finish); }","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  828","line":""},
{"lineNum":"  829","line":"      /**"},
{"lineNum":"  830","line":"       *  Returns a read-only (constant) iterator that points one past"},
{"lineNum":"  831","line":"       *  the last element in the %vector.  Iteration is done in"},
{"lineNum":"  832","line":"       *  ordinary element order."},
{"lineNum":"  833","line":"       */"},
{"lineNum":"  834","line":"      const_iterator"},
{"lineNum":"  835","line":"      end() const _GLIBCXX_NOEXCEPT","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  836","line":"      { return const_iterator(this->_M_impl._M_finish); }","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  837","line":""},
{"lineNum":"  838","line":"      /**"},
{"lineNum":"  839","line":"       *  Returns a read/write reverse iterator that points to the"},
{"lineNum":"  840","line":"       *  last element in the %vector.  Iteration is done in reverse"},
{"lineNum":"  841","line":"       *  element order."},
{"lineNum":"  842","line":"       */"},
{"lineNum":"  843","line":"      reverse_iterator"},
{"lineNum":"  844","line":"      rbegin() _GLIBCXX_NOEXCEPT"},
{"lineNum":"  845","line":"      { return reverse_iterator(end()); }"},
{"lineNum":"  846","line":""},
{"lineNum":"  847","line":"      /**"},
{"lineNum":"  848","line":"       *  Returns a read-only (constant) reverse iterator that points"},
{"lineNum":"  849","line":"       *  to the last element in the %vector.  Iteration is done in"},
{"lineNum":"  850","line":"       *  reverse element order."},
{"lineNum":"  851","line":"       */"},
{"lineNum":"  852","line":"      const_reverse_iterator"},
{"lineNum":"  853","line":"      rbegin() const _GLIBCXX_NOEXCEPT"},
{"lineNum":"  854","line":"      { return const_reverse_iterator(end()); }"},
{"lineNum":"  855","line":""},
{"lineNum":"  856","line":"      /**"},
{"lineNum":"  857","line":"       *  Returns a read/write reverse iterator that points to one"},
{"lineNum":"  858","line":"       *  before the first element in the %vector.  Iteration is done"},
{"lineNum":"  859","line":"       *  in reverse element order."},
{"lineNum":"  860","line":"       */"},
{"lineNum":"  861","line":"      reverse_iterator"},
{"lineNum":"  862","line":"      rend() _GLIBCXX_NOEXCEPT"},
{"lineNum":"  863","line":"      { return reverse_iterator(begin()); }"},
{"lineNum":"  864","line":""},
{"lineNum":"  865","line":"      /**"},
{"lineNum":"  866","line":"       *  Returns a read-only (constant) reverse iterator that points"},
{"lineNum":"  867","line":"       *  to one before the first element in the %vector.  Iteration"},
{"lineNum":"  868","line":"       *  is done in reverse element order."},
{"lineNum":"  869","line":"       */"},
{"lineNum":"  870","line":"      const_reverse_iterator"},
{"lineNum":"  871","line":"      rend() const _GLIBCXX_NOEXCEPT"},
{"lineNum":"  872","line":"      { return const_reverse_iterator(begin()); }"},
{"lineNum":"  873","line":""},
{"lineNum":"  874","line":"#if __cplusplus >= 201103L"},
{"lineNum":"  875","line":"      /**"},
{"lineNum":"  876","line":"       *  Returns a read-only (constant) iterator that points to the"},
{"lineNum":"  877","line":"       *  first element in the %vector.  Iteration is done in ordinary"},
{"lineNum":"  878","line":"       *  element order."},
{"lineNum":"  879","line":"       */"},
{"lineNum":"  880","line":"      const_iterator"},
{"lineNum":"  881","line":"      cbegin() const noexcept","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  882","line":"      { return const_iterator(this->_M_impl._M_start); }","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  883","line":""},
{"lineNum":"  884","line":"      /**"},
{"lineNum":"  885","line":"       *  Returns a read-only (constant) iterator that points one past"},
{"lineNum":"  886","line":"       *  the last element in the %vector.  Iteration is done in"},
{"lineNum":"  887","line":"       *  ordinary element order."},
{"lineNum":"  888","line":"       */"},
{"lineNum":"  889","line":"      const_iterator"},
{"lineNum":"  890","line":"      cend() const noexcept"},
{"lineNum":"  891","line":"      { return const_iterator(this->_M_impl._M_finish); }"},
{"lineNum":"  892","line":""},
{"lineNum":"  893","line":"      /**"},
{"lineNum":"  894","line":"       *  Returns a read-only (constant) reverse iterator that points"},
{"lineNum":"  895","line":"       *  to the last element in the %vector.  Iteration is done in"},
{"lineNum":"  896","line":"       *  reverse element order."},
{"lineNum":"  897","line":"       */"},
{"lineNum":"  898","line":"      const_reverse_iterator"},
{"lineNum":"  899","line":"      crbegin() const noexcept"},
{"lineNum":"  900","line":"      { return const_reverse_iterator(end()); }"},
{"lineNum":"  901","line":""},
{"lineNum":"  902","line":"      /**"},
{"lineNum":"  903","line":"       *  Returns a read-only (constant) reverse iterator that points"},
{"lineNum":"  904","line":"       *  to one before the first element in the %vector.  Iteration"},
{"lineNum":"  905","line":"       *  is done in reverse element order."},
{"lineNum":"  906","line":"       */"},
{"lineNum":"  907","line":"      const_reverse_iterator"},
{"lineNum":"  908","line":"      crend() const noexcept"},
{"lineNum":"  909","line":"      { return const_reverse_iterator(begin()); }"},
{"lineNum":"  910","line":"#endif"},
{"lineNum":"  911","line":""},
{"lineNum":"  912","line":"      // [23.2.4.2] capacity"},
{"lineNum":"  913","line":"      /**  Returns the number of elements in the %vector.  */"},
{"lineNum":"  914","line":"      size_type"},
{"lineNum":"  915","line":"      size() const _GLIBCXX_NOEXCEPT","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  916","line":"      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":"  917","line":""},
{"lineNum":"  918","line":"      /**  Returns the size() of the largest possible %vector.  */"},
{"lineNum":"  919","line":"      size_type"},
{"lineNum":"  920","line":"      max_size() const _GLIBCXX_NOEXCEPT","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  921","line":"      { return _S_max_size(_M_get_Tp_allocator()); }","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  922","line":""},
{"lineNum":"  923","line":"#if __cplusplus >= 201103L"},
{"lineNum":"  924","line":"      /**"},
{"lineNum":"  925","line":"       *  @brief  Resizes the %vector to the specified number of elements."},
{"lineNum":"  926","line":"       *  @param  __new_size  Number of elements the %vector should contain."},
{"lineNum":"  927","line":"       *"},
{"lineNum":"  928","line":"       *  This function will %resize the %vector to the specified"},
{"lineNum":"  929","line":"       *  number of elements.  If the number is smaller than the"},
{"lineNum":"  930","line":"       *  %vector\'s current size the %vector is truncated, otherwise"},
{"lineNum":"  931","line":"       *  default constructed elements are appended."},
{"lineNum":"  932","line":"       */"},
{"lineNum":"  933","line":"      void"},
{"lineNum":"  934","line":"      resize(size_type __new_size)","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  935","line":"      {"},
{"lineNum":"  936","line":"\tif (__new_size > size())","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  937","line":"\t  _M_default_append(__new_size - size());","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  938","line":"\telse if (__new_size < size())","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  939","line":"\t  _M_erase_at_end(this->_M_impl._M_start + __new_size);","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  940","line":"      }","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  941","line":""},
{"lineNum":"  942","line":"      /**"},
{"lineNum":"  943","line":"       *  @brief  Resizes the %vector to the specified number of elements."},
{"lineNum":"  944","line":"       *  @param  __new_size  Number of elements the %vector should contain."},
{"lineNum":"  945","line":"       *  @param  __x  Data with which new elements should be populated."},
{"lineNum":"  946","line":"       *"},
{"lineNum":"  947","line":"       *  This function will %resize the %vector to the specified"},
{"lineNum":"  948","line":"       *  number of elements.  If the number is smaller than the"},
{"lineNum":"  949","line":"       *  %vector\'s current size the %vector is truncated, otherwise"},
{"lineNum":"  950","line":"       *  the %vector is extended and new elements are populated with"},
{"lineNum":"  951","line":"       *  given data."},
{"lineNum":"  952","line":"       */"},
{"lineNum":"  953","line":"      void"},
{"lineNum":"  954","line":"      resize(size_type __new_size, const value_type& __x)"},
{"lineNum":"  955","line":"      {"},
{"lineNum":"  956","line":"\tif (__new_size > size())"},
{"lineNum":"  957","line":"\t  _M_fill_insert(end(), __new_size - size(), __x);"},
{"lineNum":"  958","line":"\telse if (__new_size < size())"},
{"lineNum":"  959","line":"\t  _M_erase_at_end(this->_M_impl._M_start + __new_size);"},
{"lineNum":"  960","line":"      }"},
{"lineNum":"  961","line":"#else"},
{"lineNum":"  962","line":"      /**"},
{"lineNum":"  963","line":"       *  @brief  Resizes the %vector to the specified number of elements."},
{"lineNum":"  964","line":"       *  @param  __new_size  Number of elements the %vector should contain."},
{"lineNum":"  965","line":"       *  @param  __x  Data with which new elements should be populated."},
{"lineNum":"  966","line":"       *"},
{"lineNum":"  967","line":"       *  This function will %resize the %vector to the specified"},
{"lineNum":"  968","line":"       *  number of elements.  If the number is smaller than the"},
{"lineNum":"  969","line":"       *  %vector\'s current size the %vector is truncated, otherwise"},
{"lineNum":"  970","line":"       *  the %vector is extended and new elements are populated with"},
{"lineNum":"  971","line":"       *  given data."},
{"lineNum":"  972","line":"       */"},
{"lineNum":"  973","line":"      void"},
{"lineNum":"  974","line":"      resize(size_type __new_size, value_type __x = value_type())"},
{"lineNum":"  975","line":"      {"},
{"lineNum":"  976","line":"\tif (__new_size > size())"},
{"lineNum":"  977","line":"\t  _M_fill_insert(end(), __new_size - size(), __x);"},
{"lineNum":"  978","line":"\telse if (__new_size < size())"},
{"lineNum":"  979","line":"\t  _M_erase_at_end(this->_M_impl._M_start + __new_size);"},
{"lineNum":"  980","line":"      }"},
{"lineNum":"  981","line":"#endif"},
{"lineNum":"  982","line":""},
{"lineNum":"  983","line":"#if __cplusplus >= 201103L"},
{"lineNum":"  984","line":"      /**  A non-binding request to reduce capacity() to size().  */"},
{"lineNum":"  985","line":"      void"},
{"lineNum":"  986","line":"      shrink_to_fit()","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  987","line":"      { _M_shrink_to_fit(); }","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  988","line":"#endif"},
{"lineNum":"  989","line":""},
{"lineNum":"  990","line":"      /**"},
{"lineNum":"  991","line":"       *  Returns the total number of elements that the %vector can"},
{"lineNum":"  992","line":"       *  hold before needing to allocate more memory."},
{"lineNum":"  993","line":"       */"},
{"lineNum":"  994","line":"      size_type"},
{"lineNum":"  995","line":"      capacity() const _GLIBCXX_NOEXCEPT","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  996","line":"      { return size_type(this->_M_impl._M_end_of_storage","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  997","line":"\t\t\t - this->_M_impl._M_start); }","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  998","line":""},
{"lineNum":"  999","line":"      /**"},
{"lineNum":" 1000","line":"       *  Returns true if the %vector is empty.  (Thus begin() would"},
{"lineNum":" 1001","line":"       *  equal end().)"},
{"lineNum":" 1002","line":"       */"},
{"lineNum":" 1003","line":"      _GLIBCXX_NODISCARD bool"},
{"lineNum":" 1004","line":"      empty() const _GLIBCXX_NOEXCEPT","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":" 1005","line":"      { return begin() == end(); }","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":" 1006","line":""},
{"lineNum":" 1007","line":"      /**"},
{"lineNum":" 1008","line":"       *  @brief  Attempt to preallocate enough memory for specified number of"},
{"lineNum":" 1009","line":"       *          elements."},
{"lineNum":" 1010","line":"       *  @param  __n  Number of elements required."},
{"lineNum":" 1011","line":"       *  @throw  std::length_error  If @a n exceeds @c max_size()."},
{"lineNum":" 1012","line":"       *"},
{"lineNum":" 1013","line":"       *  This function attempts to reserve enough memory for the"},
{"lineNum":" 1014","line":"       *  %vector to hold the specified number of elements.  If the"},
{"lineNum":" 1015","line":"       *  number requested is more than max_size(), length_error is"},
{"lineNum":" 1016","line":"       *  thrown."},
{"lineNum":" 1017","line":"       *"},
{"lineNum":" 1018","line":"       *  The advantage of this function is that if optimal code is a"},
{"lineNum":" 1019","line":"       *  necessity and the user can determine the number of elements"},
{"lineNum":" 1020","line":"       *  that will be required, the user can reserve the memory in"},
{"lineNum":" 1021","line":"       *  %advance, and thus prevent a possible reallocation of memory"},
{"lineNum":" 1022","line":"       *  and copying of %vector data."},
{"lineNum":" 1023","line":"       */"},
{"lineNum":" 1024","line":"      void"},
{"lineNum":" 1025","line":"      reserve(size_type __n);"},
{"lineNum":" 1026","line":""},
{"lineNum":" 1027","line":"      // element access"},
{"lineNum":" 1028","line":"      /**"},
{"lineNum":" 1029","line":"       *  @brief  Subscript access to the data contained in the %vector."},
{"lineNum":" 1030","line":"       *  @param __n The index of the element for which data should be"},
{"lineNum":" 1031","line":"       *  accessed."},
{"lineNum":" 1032","line":"       *  @return  Read/write reference to data."},
{"lineNum":" 1033","line":"       *"},
{"lineNum":" 1034","line":"       *  This operator allows for easy, array-style, data access."},
{"lineNum":" 1035","line":"       *  Note that data access with this operator is unchecked and"},
{"lineNum":" 1036","line":"       *  out_of_range lookups are not defined. (For checked lookups"},
{"lineNum":" 1037","line":"       *  see at().)"},
{"lineNum":" 1038","line":"       */"},
{"lineNum":" 1039","line":"      reference"},
{"lineNum":" 1040","line":"      operator[](size_type __n) _GLIBCXX_NOEXCEPT","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 1041","line":"      {"},
{"lineNum":" 1042","line":"\t__glibcxx_requires_subscript(__n);"},
{"lineNum":" 1043","line":"\treturn *(this->_M_impl._M_start + __n);","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":" 1044","line":"      }","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":" 1045","line":""},
{"lineNum":" 1046","line":"      /**"},
{"lineNum":" 1047","line":"       *  @brief  Subscript access to the data contained in the %vector."},
{"lineNum":" 1048","line":"       *  @param __n The index of the element for which data should be"},
{"lineNum":" 1049","line":"       *  accessed."},
{"lineNum":" 1050","line":"       *  @return  Read-only (constant) reference to data."},
{"lineNum":" 1051","line":"       *"},
{"lineNum":" 1052","line":"       *  This operator allows for easy, array-style, data access."},
{"lineNum":" 1053","line":"       *  Note that data access with this operator is unchecked and"},
{"lineNum":" 1054","line":"       *  out_of_range lookups are not defined. (For checked lookups"},
{"lineNum":" 1055","line":"       *  see at().)"},
{"lineNum":" 1056","line":"       */"},
{"lineNum":" 1057","line":"      const_reference"},
{"lineNum":" 1058","line":"      operator[](size_type __n) const _GLIBCXX_NOEXCEPT","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 1059","line":"      {"},
{"lineNum":" 1060","line":"\t__glibcxx_requires_subscript(__n);"},
{"lineNum":" 1061","line":"\treturn *(this->_M_impl._M_start + __n);","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":" 1062","line":"      }","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":" 1063","line":""},
{"lineNum":" 1064","line":"    protected:"},
{"lineNum":" 1065","line":"      /// Safety check used only from at()."},
{"lineNum":" 1066","line":"      void"},
{"lineNum":" 1067","line":"      _M_range_check(size_type __n) const"},
{"lineNum":" 1068","line":"      {"},
{"lineNum":" 1069","line":"\tif (__n >= this->size())"},
{"lineNum":" 1070","line":"\t  __throw_out_of_range_fmt(__N(\"vector::_M_range_check: __n \""},
{"lineNum":" 1071","line":"\t\t\t\t       \"(which is %zu) >= this->size() \""},
{"lineNum":" 1072","line":"\t\t\t\t       \"(which is %zu)\"),"},
{"lineNum":" 1073","line":"\t\t\t\t   __n, this->size());"},
{"lineNum":" 1074","line":"      }"},
{"lineNum":" 1075","line":""},
{"lineNum":" 1076","line":"    public:"},
{"lineNum":" 1077","line":"      /**"},
{"lineNum":" 1078","line":"       *  @brief  Provides access to the data contained in the %vector."},
{"lineNum":" 1079","line":"       *  @param __n The index of the element for which data should be"},
{"lineNum":" 1080","line":"       *  accessed."},
{"lineNum":" 1081","line":"       *  @return  Read/write reference to data."},
{"lineNum":" 1082","line":"       *  @throw  std::out_of_range  If @a __n is an invalid index."},
{"lineNum":" 1083","line":"       *"},
{"lineNum":" 1084","line":"       *  This function provides for safer data access.  The parameter"},
{"lineNum":" 1085","line":"       *  is first checked that it is in the range of the vector.  The"},
{"lineNum":" 1086","line":"       *  function throws out_of_range if the check fails."},
{"lineNum":" 1087","line":"       */"},
{"lineNum":" 1088","line":"      reference"},
{"lineNum":" 1089","line":"      at(size_type __n)"},
{"lineNum":" 1090","line":"      {"},
{"lineNum":" 1091","line":"\t_M_range_check(__n);"},
{"lineNum":" 1092","line":"\treturn (*this)[__n];"},
{"lineNum":" 1093","line":"      }"},
{"lineNum":" 1094","line":""},
{"lineNum":" 1095","line":"      /**"},
{"lineNum":" 1096","line":"       *  @brief  Provides access to the data contained in the %vector."},
{"lineNum":" 1097","line":"       *  @param __n The index of the element for which data should be"},
{"lineNum":" 1098","line":"       *  accessed."},
{"lineNum":" 1099","line":"       *  @return  Read-only (constant) reference to data."},
{"lineNum":" 1100","line":"       *  @throw  std::out_of_range  If @a __n is an invalid index."},
{"lineNum":" 1101","line":"       *"},
{"lineNum":" 1102","line":"       *  This function provides for safer data access.  The parameter"},
{"lineNum":" 1103","line":"       *  is first checked that it is in the range of the vector.  The"},
{"lineNum":" 1104","line":"       *  function throws out_of_range if the check fails."},
{"lineNum":" 1105","line":"       */"},
{"lineNum":" 1106","line":"      const_reference"},
{"lineNum":" 1107","line":"      at(size_type __n) const"},
{"lineNum":" 1108","line":"      {"},
{"lineNum":" 1109","line":"\t_M_range_check(__n);"},
{"lineNum":" 1110","line":"\treturn (*this)[__n];"},
{"lineNum":" 1111","line":"      }"},
{"lineNum":" 1112","line":""},
{"lineNum":" 1113","line":"      /**"},
{"lineNum":" 1114","line":"       *  Returns a read/write reference to the data at the first"},
{"lineNum":" 1115","line":"       *  element of the %vector."},
{"lineNum":" 1116","line":"       */"},
{"lineNum":" 1117","line":"      reference"},
{"lineNum":" 1118","line":"      front() _GLIBCXX_NOEXCEPT"},
{"lineNum":" 1119","line":"      {"},
{"lineNum":" 1120","line":"\t__glibcxx_requires_nonempty();"},
{"lineNum":" 1121","line":"\treturn *begin();"},
{"lineNum":" 1122","line":"      }"},
{"lineNum":" 1123","line":""},
{"lineNum":" 1124","line":"      /**"},
{"lineNum":" 1125","line":"       *  Returns a read-only (constant) reference to the data at the first"},
{"lineNum":" 1126","line":"       *  element of the %vector."},
{"lineNum":" 1127","line":"       */"},
{"lineNum":" 1128","line":"      const_reference"},
{"lineNum":" 1129","line":"      front() const _GLIBCXX_NOEXCEPT"},
{"lineNum":" 1130","line":"      {"},
{"lineNum":" 1131","line":"\t__glibcxx_requires_nonempty();"},
{"lineNum":" 1132","line":"\treturn *begin();"},
{"lineNum":" 1133","line":"      }"},
{"lineNum":" 1134","line":""},
{"lineNum":" 1135","line":"      /**"},
{"lineNum":" 1136","line":"       *  Returns a read/write reference to the data at the last"},
{"lineNum":" 1137","line":"       *  element of the %vector."},
{"lineNum":" 1138","line":"       */"},
{"lineNum":" 1139","line":"      reference"},
{"lineNum":" 1140","line":"      back() _GLIBCXX_NOEXCEPT"},
{"lineNum":" 1141","line":"      {"},
{"lineNum":" 1142","line":"\t__glibcxx_requires_nonempty();"},
{"lineNum":" 1143","line":"\treturn *(end() - 1);"},
{"lineNum":" 1144","line":"      }"},
{"lineNum":" 1145","line":""},
{"lineNum":" 1146","line":"      /**"},
{"lineNum":" 1147","line":"       *  Returns a read-only (constant) reference to the data at the"},
{"lineNum":" 1148","line":"       *  last element of the %vector."},
{"lineNum":" 1149","line":"       */"},
{"lineNum":" 1150","line":"      const_reference"},
{"lineNum":" 1151","line":"      back() const _GLIBCXX_NOEXCEPT"},
{"lineNum":" 1152","line":"      {"},
{"lineNum":" 1153","line":"\t__glibcxx_requires_nonempty();"},
{"lineNum":" 1154","line":"\treturn *(end() - 1);"},
{"lineNum":" 1155","line":"      }"},
{"lineNum":" 1156","line":""},
{"lineNum":" 1157","line":"      // _GLIBCXX_RESOLVE_LIB_DEFECTS"},
{"lineNum":" 1158","line":"      // DR 464. Suggestion for new member functions in standard containers."},
{"lineNum":" 1159","line":"      // data access"},
{"lineNum":" 1160","line":"      /**"},
{"lineNum":" 1161","line":"       *   Returns a pointer such that [data(), data() + size()) is a valid"},
{"lineNum":" 1162","line":"       *   range.  For a non-empty %vector, data() == &front()."},
{"lineNum":" 1163","line":"       */"},
{"lineNum":" 1164","line":"      _Tp*"},
{"lineNum":" 1165","line":"      data() _GLIBCXX_NOEXCEPT","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 1166","line":"      { return _M_data_ptr(this->_M_impl._M_start); }","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":" 1167","line":""},
{"lineNum":" 1168","line":"      const _Tp*"},
{"lineNum":" 1169","line":"      data() const _GLIBCXX_NOEXCEPT"},
{"lineNum":" 1170","line":"      { return _M_data_ptr(this->_M_impl._M_start); }"},
{"lineNum":" 1171","line":""},
{"lineNum":" 1172","line":"      // [23.2.4.3] modifiers"},
{"lineNum":" 1173","line":"      /**"},
{"lineNum":" 1174","line":"       *  @brief  Add data to the end of the %vector."},
{"lineNum":" 1175","line":"       *  @param  __x  Data to be added."},
{"lineNum":" 1176","line":"       *"},
{"lineNum":" 1177","line":"       *  This is a typical stack operation.  The function creates an"},
{"lineNum":" 1178","line":"       *  element at the end of the %vector and assigns the given data"},
{"lineNum":" 1179","line":"       *  to it.  Due to the nature of a %vector this operation can be"},
{"lineNum":" 1180","line":"       *  done in constant time if the %vector has preallocated space"},
{"lineNum":" 1181","line":"       *  available."},
{"lineNum":" 1182","line":"       */"},
{"lineNum":" 1183","line":"      void"},
{"lineNum":" 1184","line":"      push_back(const value_type& __x)"},
{"lineNum":" 1185","line":"      {"},
{"lineNum":" 1186","line":"\tif (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)"},
{"lineNum":" 1187","line":"\t  {"},
{"lineNum":" 1188","line":"\t    _GLIBCXX_ASAN_ANNOTATE_GROW(1);"},
{"lineNum":" 1189","line":"\t    _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,"},
{"lineNum":" 1190","line":"\t\t\t\t     __x);"},
{"lineNum":" 1191","line":"\t    ++this->_M_impl._M_finish;"},
{"lineNum":" 1192","line":"\t    _GLIBCXX_ASAN_ANNOTATE_GREW(1);"},
{"lineNum":" 1193","line":"\t  }"},
{"lineNum":" 1194","line":"\telse"},
{"lineNum":" 1195","line":"\t  _M_realloc_insert(end(), __x);"},
{"lineNum":" 1196","line":"      }"},
{"lineNum":" 1197","line":""},
{"lineNum":" 1198","line":"#if __cplusplus >= 201103L"},
{"lineNum":" 1199","line":"      void"},
{"lineNum":" 1200","line":"      push_back(value_type&& __x)","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 1201","line":"      { emplace_back(std::move(__x)); }","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":" 1202","line":""},
{"lineNum":" 1203","line":"      template<typename... _Args>"},
{"lineNum":" 1204","line":"#if __cplusplus > 201402L"},
{"lineNum":" 1205","line":"\treference"},
{"lineNum":" 1206","line":"#else"},
{"lineNum":" 1207","line":"\tvoid"},
{"lineNum":" 1208","line":"#endif"},
{"lineNum":" 1209","line":"\templace_back(_Args&&... __args);"},
{"lineNum":" 1210","line":"#endif"},
{"lineNum":" 1211","line":""},
{"lineNum":" 1212","line":"      /**"},
{"lineNum":" 1213","line":"       *  @brief  Removes last element."},
{"lineNum":" 1214","line":"       *"},
{"lineNum":" 1215","line":"       *  This is a typical stack operation. It shrinks the %vector by one."},
{"lineNum":" 1216","line":"       *"},
{"lineNum":" 1217","line":"       *  Note that no data is returned, and if the last element\'s"},
{"lineNum":" 1218","line":"       *  data is needed, it should be retrieved before pop_back() is"},
{"lineNum":" 1219","line":"       *  called."},
{"lineNum":" 1220","line":"       */"},
{"lineNum":" 1221","line":"      void"},
{"lineNum":" 1222","line":"      pop_back() _GLIBCXX_NOEXCEPT"},
{"lineNum":" 1223","line":"      {"},
{"lineNum":" 1224","line":"\t__glibcxx_requires_nonempty();"},
{"lineNum":" 1225","line":"\t--this->_M_impl._M_finish;"},
{"lineNum":" 1226","line":"\t_Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);"},
{"lineNum":" 1227","line":"\t_GLIBCXX_ASAN_ANNOTATE_SHRINK(1);"},
{"lineNum":" 1228","line":"      }"},
{"lineNum":" 1229","line":""},
{"lineNum":" 1230","line":"#if __cplusplus >= 201103L"},
{"lineNum":" 1231","line":"      /**"},
{"lineNum":" 1232","line":"       *  @brief  Inserts an object in %vector before specified iterator."},
{"lineNum":" 1233","line":"       *  @param  __position  A const_iterator into the %vector."},
{"lineNum":" 1234","line":"       *  @param  __args  Arguments."},
{"lineNum":" 1235","line":"       *  @return  An iterator that points to the inserted data."},
{"lineNum":" 1236","line":"       *"},
{"lineNum":" 1237","line":"       *  This function will insert an object of type T constructed"},
{"lineNum":" 1238","line":"       *  with T(std::forward<Args>(args)...) before the specified location."},
{"lineNum":" 1239","line":"       *  Note that this kind of operation could be expensive for a %vector"},
{"lineNum":" 1240","line":"       *  and if it is frequently used the user should consider using"},
{"lineNum":" 1241","line":"       *  std::list."},
{"lineNum":" 1242","line":"       */"},
{"lineNum":" 1243","line":"      template<typename... _Args>"},
{"lineNum":" 1244","line":"\titerator"},
{"lineNum":" 1245","line":"\templace(const_iterator __position, _Args&&... __args)"},
{"lineNum":" 1246","line":"\t{ return _M_emplace_aux(__position, std::forward<_Args>(__args)...); }"},
{"lineNum":" 1247","line":""},
{"lineNum":" 1248","line":"      /**"},
{"lineNum":" 1249","line":"       *  @brief  Inserts given value into %vector before specified iterator."},
{"lineNum":" 1250","line":"       *  @param  __position  A const_iterator into the %vector."},
{"lineNum":" 1251","line":"       *  @param  __x  Data to be inserted."},
{"lineNum":" 1252","line":"       *  @return  An iterator that points to the inserted data."},
{"lineNum":" 1253","line":"       *"},
{"lineNum":" 1254","line":"       *  This function will insert a copy of the given value before"},
{"lineNum":" 1255","line":"       *  the specified location.  Note that this kind of operation"},
{"lineNum":" 1256","line":"       *  could be expensive for a %vector and if it is frequently"},
{"lineNum":" 1257","line":"       *  used the user should consider using std::list."},
{"lineNum":" 1258","line":"       */"},
{"lineNum":" 1259","line":"      iterator"},
{"lineNum":" 1260","line":"      insert(const_iterator __position, const value_type& __x);"},
{"lineNum":" 1261","line":"#else"},
{"lineNum":" 1262","line":"      /**"},
{"lineNum":" 1263","line":"       *  @brief  Inserts given value into %vector before specified iterator."},
{"lineNum":" 1264","line":"       *  @param  __position  An iterator into the %vector."},
{"lineNum":" 1265","line":"       *  @param  __x  Data to be inserted."},
{"lineNum":" 1266","line":"       *  @return  An iterator that points to the inserted data."},
{"lineNum":" 1267","line":"       *"},
{"lineNum":" 1268","line":"       *  This function will insert a copy of the given value before"},
{"lineNum":" 1269","line":"       *  the specified location.  Note that this kind of operation"},
{"lineNum":" 1270","line":"       *  could be expensive for a %vector and if it is frequently"},
{"lineNum":" 1271","line":"       *  used the user should consider using std::list."},
{"lineNum":" 1272","line":"       */"},
{"lineNum":" 1273","line":"      iterator"},
{"lineNum":" 1274","line":"      insert(iterator __position, const value_type& __x);"},
{"lineNum":" 1275","line":"#endif"},
{"lineNum":" 1276","line":""},
{"lineNum":" 1277","line":"#if __cplusplus >= 201103L"},
{"lineNum":" 1278","line":"      /**"},
{"lineNum":" 1279","line":"       *  @brief  Inserts given rvalue into %vector before specified iterator."},
{"lineNum":" 1280","line":"       *  @param  __position  A const_iterator into the %vector."},
{"lineNum":" 1281","line":"       *  @param  __x  Data to be inserted."},
{"lineNum":" 1282","line":"       *  @return  An iterator that points to the inserted data."},
{"lineNum":" 1283","line":"       *"},
{"lineNum":" 1284","line":"       *  This function will insert a copy of the given rvalue before"},
{"lineNum":" 1285","line":"       *  the specified location.  Note that this kind of operation"},
{"lineNum":" 1286","line":"       *  could be expensive for a %vector and if it is frequently"},
{"lineNum":" 1287","line":"       *  used the user should consider using std::list."},
{"lineNum":" 1288","line":"       */"},
{"lineNum":" 1289","line":"      iterator"},
{"lineNum":" 1290","line":"      insert(const_iterator __position, value_type&& __x)"},
{"lineNum":" 1291","line":"      { return _M_insert_rval(__position, std::move(__x)); }"},
{"lineNum":" 1292","line":""},
{"lineNum":" 1293","line":"      /**"},
{"lineNum":" 1294","line":"       *  @brief  Inserts an initializer_list into the %vector."},
{"lineNum":" 1295","line":"       *  @param  __position  An iterator into the %vector."},
{"lineNum":" 1296","line":"       *  @param  __l  An initializer_list."},
{"lineNum":" 1297","line":"       *"},
{"lineNum":" 1298","line":"       *  This function will insert copies of the data in the"},
{"lineNum":" 1299","line":"       *  initializer_list @a l into the %vector before the location"},
{"lineNum":" 1300","line":"       *  specified by @a position."},
{"lineNum":" 1301","line":"       *"},
{"lineNum":" 1302","line":"       *  Note that this kind of operation could be expensive for a"},
{"lineNum":" 1303","line":"       *  %vector and if it is frequently used the user should"},
{"lineNum":" 1304","line":"       *  consider using std::list."},
{"lineNum":" 1305","line":"       */"},
{"lineNum":" 1306","line":"      iterator"},
{"lineNum":" 1307","line":"      insert(const_iterator __position, initializer_list<value_type> __l)"},
{"lineNum":" 1308","line":"      {"},
{"lineNum":" 1309","line":"\tauto __offset = __position - cbegin();"},
{"lineNum":" 1310","line":"\t_M_range_insert(begin() + __offset, __l.begin(), __l.end(),"},
{"lineNum":" 1311","line":"\t\t\tstd::random_access_iterator_tag());"},
{"lineNum":" 1312","line":"\treturn begin() + __offset;"},
{"lineNum":" 1313","line":"      }"},
{"lineNum":" 1314","line":"#endif"},
{"lineNum":" 1315","line":""},
{"lineNum":" 1316","line":"#if __cplusplus >= 201103L"},
{"lineNum":" 1317","line":"      /**"},
{"lineNum":" 1318","line":"       *  @brief  Inserts a number of copies of given data into the %vector."},
{"lineNum":" 1319","line":"       *  @param  __position  A const_iterator into the %vector."},
{"lineNum":" 1320","line":"       *  @param  __n  Number of elements to be inserted."},
{"lineNum":" 1321","line":"       *  @param  __x  Data to be inserted."},
{"lineNum":" 1322","line":"       *  @return  An iterator that points to the inserted data."},
{"lineNum":" 1323","line":"       *"},
{"lineNum":" 1324","line":"       *  This function will insert a specified number of copies of"},
{"lineNum":" 1325","line":"       *  the given data before the location specified by @a position."},
{"lineNum":" 1326","line":"       *"},
{"lineNum":" 1327","line":"       *  Note that this kind of operation could be expensive for a"},
{"lineNum":" 1328","line":"       *  %vector and if it is frequently used the user should"},
{"lineNum":" 1329","line":"       *  consider using std::list."},
{"lineNum":" 1330","line":"       */"},
{"lineNum":" 1331","line":"      iterator"},
{"lineNum":" 1332","line":"      insert(const_iterator __position, size_type __n, const value_type& __x)"},
{"lineNum":" 1333","line":"      {"},
{"lineNum":" 1334","line":"\tdifference_type __offset = __position - cbegin();"},
{"lineNum":" 1335","line":"\t_M_fill_insert(begin() + __offset, __n, __x);"},
{"lineNum":" 1336","line":"\treturn begin() + __offset;"},
{"lineNum":" 1337","line":"      }"},
{"lineNum":" 1338","line":"#else"},
{"lineNum":" 1339","line":"      /**"},
{"lineNum":" 1340","line":"       *  @brief  Inserts a number of copies of given data into the %vector."},
{"lineNum":" 1341","line":"       *  @param  __position  An iterator into the %vector."},
{"lineNum":" 1342","line":"       *  @param  __n  Number of elements to be inserted."},
{"lineNum":" 1343","line":"       *  @param  __x  Data to be inserted."},
{"lineNum":" 1344","line":"       *"},
{"lineNum":" 1345","line":"       *  This function will insert a specified number of copies of"},
{"lineNum":" 1346","line":"       *  the given data before the location specified by @a position."},
{"lineNum":" 1347","line":"       *"},
{"lineNum":" 1348","line":"       *  Note that this kind of operation could be expensive for a"},
{"lineNum":" 1349","line":"       *  %vector and if it is frequently used the user should"},
{"lineNum":" 1350","line":"       *  consider using std::list."},
{"lineNum":" 1351","line":"       */"},
{"lineNum":" 1352","line":"      void"},
{"lineNum":" 1353","line":"      insert(iterator __position, size_type __n, const value_type& __x)"},
{"lineNum":" 1354","line":"      { _M_fill_insert(__position, __n, __x); }"},
{"lineNum":" 1355","line":"#endif"},
{"lineNum":" 1356","line":""},
{"lineNum":" 1357","line":"#if __cplusplus >= 201103L"},
{"lineNum":" 1358","line":"      /**"},
{"lineNum":" 1359","line":"       *  @brief  Inserts a range into the %vector."},
{"lineNum":" 1360","line":"       *  @param  __position  A const_iterator into the %vector."},
{"lineNum":" 1361","line":"       *  @param  __first  An input iterator."},
{"lineNum":" 1362","line":"       *  @param  __last   An input iterator."},
{"lineNum":" 1363","line":"       *  @return  An iterator that points to the inserted data."},
{"lineNum":" 1364","line":"       *"},
{"lineNum":" 1365","line":"       *  This function will insert copies of the data in the range"},
{"lineNum":" 1366","line":"       *  [__first,__last) into the %vector before the location specified"},
{"lineNum":" 1367","line":"       *  by @a pos."},
{"lineNum":" 1368","line":"       *"},
{"lineNum":" 1369","line":"       *  Note that this kind of operation could be expensive for a"},
{"lineNum":" 1370","line":"       *  %vector and if it is frequently used the user should"},
{"lineNum":" 1371","line":"       *  consider using std::list."},
{"lineNum":" 1372","line":"       */"},
{"lineNum":" 1373","line":"      template<typename _InputIterator,"},
{"lineNum":" 1374","line":"\t       typename = std::_RequireInputIter<_InputIterator>>"},
{"lineNum":" 1375","line":"\titerator"},
{"lineNum":" 1376","line":"\tinsert(const_iterator __position, _InputIterator __first,","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":" 1377","line":"\t       _InputIterator __last)"},
{"lineNum":" 1378","line":"\t{"},
{"lineNum":" 1379","line":"\t  difference_type __offset = __position - cbegin();","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 1380","line":"\t  _M_insert_dispatch(begin() + __offset,","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":" 1381","line":"\t\t\t     __first, __last, __false_type());"},
{"lineNum":" 1382","line":"\t  return begin() + __offset;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 1383","line":"\t}","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":" 1384","line":"#else"},
{"lineNum":" 1385","line":"      /**"},
{"lineNum":" 1386","line":"       *  @brief  Inserts a range into the %vector."},
{"lineNum":" 1387","line":"       *  @param  __position  An iterator into the %vector."},
{"lineNum":" 1388","line":"       *  @param  __first  An input iterator."},
{"lineNum":" 1389","line":"       *  @param  __last   An input iterator."},
{"lineNum":" 1390","line":"       *"},
{"lineNum":" 1391","line":"       *  This function will insert copies of the data in the range"},
{"lineNum":" 1392","line":"       *  [__first,__last) into the %vector before the location specified"},
{"lineNum":" 1393","line":"       *  by @a pos."},
{"lineNum":" 1394","line":"       *"},
{"lineNum":" 1395","line":"       *  Note that this kind of operation could be expensive for a"},
{"lineNum":" 1396","line":"       *  %vector and if it is frequently used the user should"},
{"lineNum":" 1397","line":"       *  consider using std::list."},
{"lineNum":" 1398","line":"       */"},
{"lineNum":" 1399","line":"      template<typename _InputIterator>"},
{"lineNum":" 1400","line":"\tvoid"},
{"lineNum":" 1401","line":"\tinsert(iterator __position, _InputIterator __first,"},
{"lineNum":" 1402","line":"\t       _InputIterator __last)"},
{"lineNum":" 1403","line":"\t{"},
{"lineNum":" 1404","line":"\t  // Check whether it\'s an integral type.  If so, it\'s not an iterator."},
{"lineNum":" 1405","line":"\t  typedef typename std::__is_integer<_InputIterator>::__type _Integral;"},
{"lineNum":" 1406","line":"\t  _M_insert_dispatch(__position, __first, __last, _Integral());"},
{"lineNum":" 1407","line":"\t}"},
{"lineNum":" 1408","line":"#endif"},
{"lineNum":" 1409","line":""},
{"lineNum":" 1410","line":"      /**"},
{"lineNum":" 1411","line":"       *  @brief  Remove element at given position."},
{"lineNum":" 1412","line":"       *  @param  __position  Iterator pointing to element to be erased."},
{"lineNum":" 1413","line":"       *  @return  An iterator pointing to the next element (or end())."},
{"lineNum":" 1414","line":"       *"},
{"lineNum":" 1415","line":"       *  This function will erase the element at the given position and thus"},
{"lineNum":" 1416","line":"       *  shorten the %vector by one."},
{"lineNum":" 1417","line":"       *"},
{"lineNum":" 1418","line":"       *  Note This operation could be expensive and if it is"},
{"lineNum":" 1419","line":"       *  frequently used the user should consider using std::list."},
{"lineNum":" 1420","line":"       *  The user is also cautioned that this function only erases"},
{"lineNum":" 1421","line":"       *  the element, and that if the element is itself a pointer,"},
{"lineNum":" 1422","line":"       *  the pointed-to memory is not touched in any way.  Managing"},
{"lineNum":" 1423","line":"       *  the pointer is the user\'s responsibility."},
{"lineNum":" 1424","line":"       */"},
{"lineNum":" 1425","line":"      iterator"},
{"lineNum":" 1426","line":"#if __cplusplus >= 201103L"},
{"lineNum":" 1427","line":"      erase(const_iterator __position)"},
{"lineNum":" 1428","line":"      { return _M_erase(begin() + (__position - cbegin())); }"},
{"lineNum":" 1429","line":"#else"},
{"lineNum":" 1430","line":"      erase(iterator __position)"},
{"lineNum":" 1431","line":"      { return _M_erase(__position); }"},
{"lineNum":" 1432","line":"#endif"},
{"lineNum":" 1433","line":""},
{"lineNum":" 1434","line":"      /**"},
{"lineNum":" 1435","line":"       *  @brief  Remove a range of elements."},
{"lineNum":" 1436","line":"       *  @param  __first  Iterator pointing to the first element to be erased."},
{"lineNum":" 1437","line":"       *  @param  __last  Iterator pointing to one past the last element to be"},
{"lineNum":" 1438","line":"       *                  erased."},
{"lineNum":" 1439","line":"       *  @return  An iterator pointing to the element pointed to by @a __last"},
{"lineNum":" 1440","line":"       *           prior to erasing (or end())."},
{"lineNum":" 1441","line":"       *"},
{"lineNum":" 1442","line":"       *  This function will erase the elements in the range"},
{"lineNum":" 1443","line":"       *  [__first,__last) and shorten the %vector accordingly."},
{"lineNum":" 1444","line":"       *"},
{"lineNum":" 1445","line":"       *  Note This operation could be expensive and if it is"},
{"lineNum":" 1446","line":"       *  frequently used the user should consider using std::list."},
{"lineNum":" 1447","line":"       *  The user is also cautioned that this function only erases"},
{"lineNum":" 1448","line":"       *  the elements, and that if the elements themselves are"},
{"lineNum":" 1449","line":"       *  pointers, the pointed-to memory is not touched in any way."},
{"lineNum":" 1450","line":"       *  Managing the pointer is the user\'s responsibility."},
{"lineNum":" 1451","line":"       */"},
{"lineNum":" 1452","line":"      iterator"},
{"lineNum":" 1453","line":"#if __cplusplus >= 201103L"},
{"lineNum":" 1454","line":"      erase(const_iterator __first, const_iterator __last)"},
{"lineNum":" 1455","line":"      {"},
{"lineNum":" 1456","line":"\tconst auto __beg = begin();"},
{"lineNum":" 1457","line":"\tconst auto __cbeg = cbegin();"},
{"lineNum":" 1458","line":"\treturn _M_erase(__beg + (__first - __cbeg), __beg + (__last - __cbeg));"},
{"lineNum":" 1459","line":"      }"},
{"lineNum":" 1460","line":"#else"},
{"lineNum":" 1461","line":"      erase(iterator __first, iterator __last)"},
{"lineNum":" 1462","line":"      { return _M_erase(__first, __last); }"},
{"lineNum":" 1463","line":"#endif"},
{"lineNum":" 1464","line":""},
{"lineNum":" 1465","line":"      /**"},
{"lineNum":" 1466","line":"       *  @brief  Swaps data with another %vector."},
{"lineNum":" 1467","line":"       *  @param  __x  A %vector of the same element and allocator types."},
{"lineNum":" 1468","line":"       *"},
{"lineNum":" 1469","line":"       *  This exchanges the elements between two vectors in constant time."},
{"lineNum":" 1470","line":"       *  (Three pointers, so it should be quite fast.)"},
{"lineNum":" 1471","line":"       *  Note that the global std::swap() function is specialized such that"},
{"lineNum":" 1472","line":"       *  std::swap(v1,v2) will feed to this function."},
{"lineNum":" 1473","line":"       *"},
{"lineNum":" 1474","line":"       *  Whether the allocators are swapped depends on the allocator traits."},
{"lineNum":" 1475","line":"       */"},
{"lineNum":" 1476","line":"      void"},
{"lineNum":" 1477","line":"      swap(vector& __x) _GLIBCXX_NOEXCEPT","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 1478","line":"      {"},
{"lineNum":" 1479","line":"#if __cplusplus >= 201103L"},
{"lineNum":" 1480","line":"\t__glibcxx_assert(_Alloc_traits::propagate_on_container_swap::value"},
{"lineNum":" 1481","line":"\t\t\t || _M_get_Tp_allocator() == __x._M_get_Tp_allocator());"},
{"lineNum":" 1482","line":"#endif"},
{"lineNum":" 1483","line":"\tthis->_M_impl._M_swap_data(__x._M_impl);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 1484","line":"\t_Alloc_traits::_S_on_swap(_M_get_Tp_allocator(),","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":" 1485","line":"\t\t\t\t  __x._M_get_Tp_allocator());"},
{"lineNum":" 1486","line":"      }","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":" 1487","line":""},
{"lineNum":" 1488","line":"      /**"},
{"lineNum":" 1489","line":"       *  Erases all the elements.  Note that this function only erases the"},
{"lineNum":" 1490","line":"       *  elements, and that if the elements themselves are pointers, the"},
{"lineNum":" 1491","line":"       *  pointed-to memory is not touched in any way.  Managing the pointer is"},
{"lineNum":" 1492","line":"       *  the user\'s responsibility."},
{"lineNum":" 1493","line":"       */"},
{"lineNum":" 1494","line":"      void"},
{"lineNum":" 1495","line":"      clear() _GLIBCXX_NOEXCEPT"},
{"lineNum":" 1496","line":"      { _M_erase_at_end(this->_M_impl._M_start); }"},
{"lineNum":" 1497","line":""},
{"lineNum":" 1498","line":"    protected:"},
{"lineNum":" 1499","line":"      /**"},
{"lineNum":" 1500","line":"       *  Memory expansion handler.  Uses the member allocation function to"},
{"lineNum":" 1501","line":"       *  obtain @a n bytes of memory, and then copies [first,last) into it."},
{"lineNum":" 1502","line":"       */"},
{"lineNum":" 1503","line":"      template<typename _ForwardIterator>"},
{"lineNum":" 1504","line":"\tpointer"},
{"lineNum":" 1505","line":"\t_M_allocate_and_copy(size_type __n,"},
{"lineNum":" 1506","line":"\t\t\t     _ForwardIterator __first, _ForwardIterator __last)"},
{"lineNum":" 1507","line":"\t{"},
{"lineNum":" 1508","line":"\t  pointer __result = this->_M_allocate(__n);"},
{"lineNum":" 1509","line":"\t  __try"},
{"lineNum":" 1510","line":"\t    {"},
{"lineNum":" 1511","line":"\t      std::__uninitialized_copy_a(__first, __last, __result,"},
{"lineNum":" 1512","line":"\t\t\t\t\t  _M_get_Tp_allocator());"},
{"lineNum":" 1513","line":"\t      return __result;"},
{"lineNum":" 1514","line":"\t    }"},
{"lineNum":" 1515","line":"\t  __catch(...)"},
{"lineNum":" 1516","line":"\t    {"},
{"lineNum":" 1517","line":"\t      _M_deallocate(__result, __n);"},
{"lineNum":" 1518","line":"\t      __throw_exception_again;"},
{"lineNum":" 1519","line":"\t    }"},
{"lineNum":" 1520","line":"\t}"},
{"lineNum":" 1521","line":""},
{"lineNum":" 1522","line":""},
{"lineNum":" 1523","line":"      // Internal constructor functions follow."},
{"lineNum":" 1524","line":""},
{"lineNum":" 1525","line":"      // Called by the range constructor to implement [23.1.1]/9"},
{"lineNum":" 1526","line":""},
{"lineNum":" 1527","line":"#if __cplusplus < 201103L"},
{"lineNum":" 1528","line":"      // _GLIBCXX_RESOLVE_LIB_DEFECTS"},
{"lineNum":" 1529","line":"      // 438. Ambiguity in the \"do the right thing\" clause"},
{"lineNum":" 1530","line":"      template<typename _Integer>"},
{"lineNum":" 1531","line":"\tvoid"},
{"lineNum":" 1532","line":"\t_M_initialize_dispatch(_Integer __n, _Integer __value, __true_type)"},
{"lineNum":" 1533","line":"\t{"},
{"lineNum":" 1534","line":"\t  this->_M_impl._M_start = _M_allocate(_S_check_init_len("},
{"lineNum":" 1535","line":"\t\tstatic_cast<size_type>(__n), _M_get_Tp_allocator()));"},
{"lineNum":" 1536","line":"\t  this->_M_impl._M_end_of_storage ="},
{"lineNum":" 1537","line":"\t    this->_M_impl._M_start + static_cast<size_type>(__n);"},
{"lineNum":" 1538","line":"\t  _M_fill_initialize(static_cast<size_type>(__n), __value);"},
{"lineNum":" 1539","line":"\t}"},
{"lineNum":" 1540","line":""},
{"lineNum":" 1541","line":"      // Called by the range constructor to implement [23.1.1]/9"},
{"lineNum":" 1542","line":"      template<typename _InputIterator>"},
{"lineNum":" 1543","line":"\tvoid"},
{"lineNum":" 1544","line":"\t_M_initialize_dispatch(_InputIterator __first, _InputIterator __last,"},
{"lineNum":" 1545","line":"\t\t\t       __false_type)"},
{"lineNum":" 1546","line":"\t{"},
{"lineNum":" 1547","line":"\t  _M_range_initialize(__first, __last,"},
{"lineNum":" 1548","line":"\t\t\t      std::__iterator_category(__first));"},
{"lineNum":" 1549","line":"\t}"},
{"lineNum":" 1550","line":"#endif"},
{"lineNum":" 1551","line":""},
{"lineNum":" 1552","line":"      // Called by the second initialize_dispatch above"},
{"lineNum":" 1553","line":"      template<typename _InputIterator>"},
{"lineNum":" 1554","line":"\tvoid"},
{"lineNum":" 1555","line":"\t_M_range_initialize(_InputIterator __first, _InputIterator __last,"},
{"lineNum":" 1556","line":"\t\t\t    std::input_iterator_tag)"},
{"lineNum":" 1557","line":"\t{"},
{"lineNum":" 1558","line":"\t  __try {"},
{"lineNum":" 1559","line":"\t    for (; __first != __last; ++__first)"},
{"lineNum":" 1560","line":"#if __cplusplus >= 201103L"},
{"lineNum":" 1561","line":"\t      emplace_back(*__first);"},
{"lineNum":" 1562","line":"#else"},
{"lineNum":" 1563","line":"\t      push_back(*__first);"},
{"lineNum":" 1564","line":"#endif"},
{"lineNum":" 1565","line":"\t  } __catch(...) {"},
{"lineNum":" 1566","line":"\t    clear();"},
{"lineNum":" 1567","line":"\t    __throw_exception_again;"},
{"lineNum":" 1568","line":"\t  }"},
{"lineNum":" 1569","line":"\t}"},
{"lineNum":" 1570","line":""},
{"lineNum":" 1571","line":"      // Called by the second initialize_dispatch above"},
{"lineNum":" 1572","line":"      template<typename _ForwardIterator>"},
{"lineNum":" 1573","line":"\tvoid"},
{"lineNum":" 1574","line":"\t_M_range_initialize(_ForwardIterator __first, _ForwardIterator __last,","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":" 1575","line":"\t\t\t    std::forward_iterator_tag)"},
{"lineNum":" 1576","line":"\t{"},
{"lineNum":" 1577","line":"\t  const size_type __n = std::distance(__first, __last);","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":" 1578","line":"\t  this->_M_impl._M_start","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":" 1579","line":"\t    = this->_M_allocate(_S_check_init_len(__n, _M_get_Tp_allocator()));","class":"lineNoCov","hits":"0","possible_hits":"6",},
{"lineNum":" 1580","line":"\t  this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;","class":"lineNoCov","hits":"0","possible_hits":"6",},
{"lineNum":" 1581","line":"\t  this->_M_impl._M_finish =","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":" 1582","line":"\t    std::__uninitialized_copy_a(__first, __last,","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":" 1583","line":"\t\t\t\t\tthis->_M_impl._M_start,"},
{"lineNum":" 1584","line":"\t\t\t\t\t_M_get_Tp_allocator());","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":" 1585","line":"\t}","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":" 1586","line":""},
{"lineNum":" 1587","line":"      // Called by the first initialize_dispatch above and by the"},
{"lineNum":" 1588","line":"      // vector(n,value,a) constructor."},
{"lineNum":" 1589","line":"      void"},
{"lineNum":" 1590","line":"      _M_fill_initialize(size_type __n, const value_type& __value)"},
{"lineNum":" 1591","line":"      {"},
{"lineNum":" 1592","line":"\tthis->_M_impl._M_finish ="},
{"lineNum":" 1593","line":"\t  std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value,"},
{"lineNum":" 1594","line":"\t\t\t\t\t_M_get_Tp_allocator());"},
{"lineNum":" 1595","line":"      }"},
{"lineNum":" 1596","line":""},
{"lineNum":" 1597","line":"#if __cplusplus >= 201103L"},
{"lineNum":" 1598","line":"      // Called by the vector(n) constructor."},
{"lineNum":" 1599","line":"      void"},
{"lineNum":" 1600","line":"      _M_default_initialize(size_type __n)","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 1601","line":"      {"},
{"lineNum":" 1602","line":"\tthis->_M_impl._M_finish =","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 1603","line":"\t  std::__uninitialized_default_n_a(this->_M_impl._M_start, __n,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 1604","line":"\t\t\t\t\t   _M_get_Tp_allocator());","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 1605","line":"      }","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":" 1606","line":"#endif"},
{"lineNum":" 1607","line":""},
{"lineNum":" 1608","line":"      // Internal assign functions follow.  The *_aux functions do the actual"},
{"lineNum":" 1609","line":"      // assignment work for the range versions."},
{"lineNum":" 1610","line":""},
{"lineNum":" 1611","line":"      // Called by the range assign to implement [23.1.1]/9"},
{"lineNum":" 1612","line":""},
{"lineNum":" 1613","line":"      // _GLIBCXX_RESOLVE_LIB_DEFECTS"},
{"lineNum":" 1614","line":"      // 438. Ambiguity in the \"do the right thing\" clause"},
{"lineNum":" 1615","line":"      template<typename _Integer>"},
{"lineNum":" 1616","line":"\tvoid"},
{"lineNum":" 1617","line":"\t_M_assign_dispatch(_Integer __n, _Integer __val, __true_type)"},
{"lineNum":" 1618","line":"\t{ _M_fill_assign(__n, __val); }"},
{"lineNum":" 1619","line":""},
{"lineNum":" 1620","line":"      // Called by the range assign to implement [23.1.1]/9"},
{"lineNum":" 1621","line":"      template<typename _InputIterator>"},
{"lineNum":" 1622","line":"\tvoid"},
{"lineNum":" 1623","line":"\t_M_assign_dispatch(_InputIterator __first, _InputIterator __last,"},
{"lineNum":" 1624","line":"\t\t\t   __false_type)"},
{"lineNum":" 1625","line":"\t{ _M_assign_aux(__first, __last, std::__iterator_category(__first)); }"},
{"lineNum":" 1626","line":""},
{"lineNum":" 1627","line":"      // Called by the second assign_dispatch above"},
{"lineNum":" 1628","line":"      template<typename _InputIterator>"},
{"lineNum":" 1629","line":"\tvoid"},
{"lineNum":" 1630","line":"\t_M_assign_aux(_InputIterator __first, _InputIterator __last,"},
{"lineNum":" 1631","line":"\t\t      std::input_iterator_tag);"},
{"lineNum":" 1632","line":""},
{"lineNum":" 1633","line":"      // Called by the second assign_dispatch above"},
{"lineNum":" 1634","line":"      template<typename _ForwardIterator>"},
{"lineNum":" 1635","line":"\tvoid"},
{"lineNum":" 1636","line":"\t_M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,"},
{"lineNum":" 1637","line":"\t\t      std::forward_iterator_tag);"},
{"lineNum":" 1638","line":""},
{"lineNum":" 1639","line":"      // Called by assign(n,t), and the range assign when it turns out"},
{"lineNum":" 1640","line":"      // to be the same thing."},
{"lineNum":" 1641","line":"      void"},
{"lineNum":" 1642","line":"      _M_fill_assign(size_type __n, const value_type& __val);"},
{"lineNum":" 1643","line":""},
{"lineNum":" 1644","line":"      // Internal insert functions follow."},
{"lineNum":" 1645","line":""},
{"lineNum":" 1646","line":"      // Called by the range insert to implement [23.1.1]/9"},
{"lineNum":" 1647","line":""},
{"lineNum":" 1648","line":"      // _GLIBCXX_RESOLVE_LIB_DEFECTS"},
{"lineNum":" 1649","line":"      // 438. Ambiguity in the \"do the right thing\" clause"},
{"lineNum":" 1650","line":"      template<typename _Integer>"},
{"lineNum":" 1651","line":"\tvoid"},
{"lineNum":" 1652","line":"\t_M_insert_dispatch(iterator __pos, _Integer __n, _Integer __val,"},
{"lineNum":" 1653","line":"\t\t\t   __true_type)"},
{"lineNum":" 1654","line":"\t{ _M_fill_insert(__pos, __n, __val); }"},
{"lineNum":" 1655","line":""},
{"lineNum":" 1656","line":"      // Called by the range insert to implement [23.1.1]/9"},
{"lineNum":" 1657","line":"      template<typename _InputIterator>"},
{"lineNum":" 1658","line":"\tvoid"},
{"lineNum":" 1659","line":"\t_M_insert_dispatch(iterator __pos, _InputIterator __first,","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":" 1660","line":"\t\t\t   _InputIterator __last, __false_type)"},
{"lineNum":" 1661","line":"\t{"},
{"lineNum":" 1662","line":"\t  _M_range_insert(__pos, __first, __last,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 1663","line":"\t\t\t  std::__iterator_category(__first));","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 1664","line":"\t}","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":" 1665","line":""},
{"lineNum":" 1666","line":"      // Called by the second insert_dispatch above"},
{"lineNum":" 1667","line":"      template<typename _InputIterator>"},
{"lineNum":" 1668","line":"\tvoid"},
{"lineNum":" 1669","line":"\t_M_range_insert(iterator __pos, _InputIterator __first,"},
{"lineNum":" 1670","line":"\t\t\t_InputIterator __last, std::input_iterator_tag);"},
{"lineNum":" 1671","line":""},
{"lineNum":" 1672","line":"      // Called by the second insert_dispatch above"},
{"lineNum":" 1673","line":"      template<typename _ForwardIterator>"},
{"lineNum":" 1674","line":"\tvoid"},
{"lineNum":" 1675","line":"\t_M_range_insert(iterator __pos, _ForwardIterator __first,"},
{"lineNum":" 1676","line":"\t\t\t_ForwardIterator __last, std::forward_iterator_tag);"},
{"lineNum":" 1677","line":""},
{"lineNum":" 1678","line":"      // Called by insert(p,n,x), and the range insert when it turns out to be"},
{"lineNum":" 1679","line":"      // the same thing."},
{"lineNum":" 1680","line":"      void"},
{"lineNum":" 1681","line":"      _M_fill_insert(iterator __pos, size_type __n, const value_type& __x);"},
{"lineNum":" 1682","line":""},
{"lineNum":" 1683","line":"#if __cplusplus >= 201103L"},
{"lineNum":" 1684","line":"      // Called by resize(n)."},
{"lineNum":" 1685","line":"      void"},
{"lineNum":" 1686","line":"      _M_default_append(size_type __n);"},
{"lineNum":" 1687","line":""},
{"lineNum":" 1688","line":"      bool"},
{"lineNum":" 1689","line":"      _M_shrink_to_fit();"},
{"lineNum":" 1690","line":"#endif"},
{"lineNum":" 1691","line":""},
{"lineNum":" 1692","line":"#if __cplusplus < 201103L"},
{"lineNum":" 1693","line":"      // Called by insert(p,x)"},
{"lineNum":" 1694","line":"      void"},
{"lineNum":" 1695","line":"      _M_insert_aux(iterator __position, const value_type& __x);"},
{"lineNum":" 1696","line":""},
{"lineNum":" 1697","line":"      void"},
{"lineNum":" 1698","line":"      _M_realloc_insert(iterator __position, const value_type& __x);"},
{"lineNum":" 1699","line":"#else"},
{"lineNum":" 1700","line":"      // A value_type object constructed with _Alloc_traits::construct()"},
{"lineNum":" 1701","line":"      // and destroyed with _Alloc_traits::destroy()."},
{"lineNum":" 1702","line":"      struct _Temporary_value"},
{"lineNum":" 1703","line":"      {"},
{"lineNum":" 1704","line":"\ttemplate<typename... _Args>"},
{"lineNum":" 1705","line":"\t  explicit"},
{"lineNum":" 1706","line":"\t  _Temporary_value(vector* __vec, _Args&&... __args) : _M_this(__vec)"},
{"lineNum":" 1707","line":"\t  {"},
{"lineNum":" 1708","line":"\t    _Alloc_traits::construct(_M_this->_M_impl, _M_ptr(),"},
{"lineNum":" 1709","line":"\t\t\t\t     std::forward<_Args>(__args)...);"},
{"lineNum":" 1710","line":"\t  }"},
{"lineNum":" 1711","line":""},
{"lineNum":" 1712","line":"\t~_Temporary_value()"},
{"lineNum":" 1713","line":"\t{ _Alloc_traits::destroy(_M_this->_M_impl, _M_ptr()); }"},
{"lineNum":" 1714","line":""},
{"lineNum":" 1715","line":"\tvalue_type&"},
{"lineNum":" 1716","line":"\t_M_val() { return *_M_ptr(); }"},
{"lineNum":" 1717","line":""},
{"lineNum":" 1718","line":"      private:"},
{"lineNum":" 1719","line":"\t_Tp*"},
{"lineNum":" 1720","line":"\t_M_ptr() { return reinterpret_cast<_Tp*>(&__buf); }"},
{"lineNum":" 1721","line":""},
{"lineNum":" 1722","line":"\tvector* _M_this;"},
{"lineNum":" 1723","line":"\ttypename aligned_storage<sizeof(_Tp), alignof(_Tp)>::type __buf;"},
{"lineNum":" 1724","line":"      };"},
{"lineNum":" 1725","line":""},
{"lineNum":" 1726","line":"      // Called by insert(p,x) and other functions when insertion needs to"},
{"lineNum":" 1727","line":"      // reallocate or move existing elements. _Arg is either _Tp& or _Tp."},
{"lineNum":" 1728","line":"      template<typename _Arg>"},
{"lineNum":" 1729","line":"\tvoid"},
{"lineNum":" 1730","line":"\t_M_insert_aux(iterator __position, _Arg&& __arg);"},
{"lineNum":" 1731","line":""},
{"lineNum":" 1732","line":"      template<typename... _Args>"},
{"lineNum":" 1733","line":"\tvoid"},
{"lineNum":" 1734","line":"\t_M_realloc_insert(iterator __position, _Args&&... __args);"},
{"lineNum":" 1735","line":""},
{"lineNum":" 1736","line":"      // Either move-construct at the end, or forward to _M_insert_aux."},
{"lineNum":" 1737","line":"      iterator"},
{"lineNum":" 1738","line":"      _M_insert_rval(const_iterator __position, value_type&& __v);"},
{"lineNum":" 1739","line":""},
{"lineNum":" 1740","line":"      // Try to emplace at the end, otherwise forward to _M_insert_aux."},
{"lineNum":" 1741","line":"      template<typename... _Args>"},
{"lineNum":" 1742","line":"\titerator"},
{"lineNum":" 1743","line":"\t_M_emplace_aux(const_iterator __position, _Args&&... __args);"},
{"lineNum":" 1744","line":""},
{"lineNum":" 1745","line":"      // Emplacing an rvalue of the correct type can use _M_insert_rval."},
{"lineNum":" 1746","line":"      iterator"},
{"lineNum":" 1747","line":"      _M_emplace_aux(const_iterator __position, value_type&& __v)"},
{"lineNum":" 1748","line":"      { return _M_insert_rval(__position, std::move(__v)); }"},
{"lineNum":" 1749","line":"#endif"},
{"lineNum":" 1750","line":""},
{"lineNum":" 1751","line":"      // Called by _M_fill_insert, _M_insert_aux etc."},
{"lineNum":" 1752","line":"      size_type"},
{"lineNum":" 1753","line":"      _M_check_len(size_type __n, const char* __s) const","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":" 1754","line":"      {"},
{"lineNum":" 1755","line":"\tif (max_size() - size() < __n)","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":" 1756","line":"\t  __throw_length_error(__N(__s));","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 1757","line":""},
{"lineNum":" 1758","line":"\tconst size_type __len = size() + (std::max)(size(), __n);","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":" 1759","line":"\treturn (__len < size() || __len > max_size()) ? max_size() : __len;","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":" 1760","line":"      }","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 1761","line":""},
{"lineNum":" 1762","line":"      // Called by constructors to check initial size."},
{"lineNum":" 1763","line":"      static size_type"},
{"lineNum":" 1764","line":"      _S_check_init_len(size_type __n, const allocator_type& __a)","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":" 1765","line":"      {"},
{"lineNum":" 1766","line":"\tif (__n > _S_max_size(_Tp_alloc_type(__a)))","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":" 1767","line":"\t  __throw_length_error(","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 1768","line":"\t      __N(\"cannot create std::vector larger than max_size()\"));"},
{"lineNum":" 1769","line":"\treturn __n;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 1770","line":"      }","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":" 1771","line":""},
{"lineNum":" 1772","line":"      static size_type"},
{"lineNum":" 1773","line":"      _S_max_size(const _Tp_alloc_type& __a) _GLIBCXX_NOEXCEPT","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":" 1774","line":"      {"},
{"lineNum":" 1775","line":"\t// std::distance(begin(), end()) cannot be greater than PTRDIFF_MAX,"},
{"lineNum":" 1776","line":"\t// and realistically we can\'t store more than PTRDIFF_MAX/sizeof(T)"},
{"lineNum":" 1777","line":"\t// (even if std::allocator_traits::max_size says we can)."},
{"lineNum":" 1778","line":"\tconst size_t __diffmax","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 1779","line":"\t  = __gnu_cxx::__numeric_traits<ptrdiff_t>::__max / sizeof(_Tp);"},
{"lineNum":" 1780","line":"\tconst size_t __allocmax = _Alloc_traits::max_size(__a);","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":" 1781","line":"\treturn (std::min)(__diffmax, __allocmax);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 1782","line":"      }","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":" 1783","line":""},
{"lineNum":" 1784","line":"      // Internal erase functions follow."},
{"lineNum":" 1785","line":""},
{"lineNum":" 1786","line":"      // Called by erase(q1,q2), clear(), resize(), _M_fill_assign,"},
{"lineNum":" 1787","line":"      // _M_assign_aux."},
{"lineNum":" 1788","line":"      void"},
{"lineNum":" 1789","line":"      _M_erase_at_end(pointer __pos) _GLIBCXX_NOEXCEPT","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 1790","line":"      {"},
{"lineNum":" 1791","line":"\tif (size_type __n = this->_M_impl._M_finish - __pos)","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":" 1792","line":"\t  {"},
{"lineNum":" 1793","line":"\t    std::_Destroy(__pos, this->_M_impl._M_finish,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 1794","line":"\t\t\t  _M_get_Tp_allocator());","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 1795","line":"\t    this->_M_impl._M_finish = __pos;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 1796","line":"\t    _GLIBCXX_ASAN_ANNOTATE_SHRINK(__n);"},
{"lineNum":" 1797","line":"\t  }"},
{"lineNum":" 1798","line":"      }","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":" 1799","line":""},
{"lineNum":" 1800","line":"      iterator"},
{"lineNum":" 1801","line":"      _M_erase(iterator __position);"},
{"lineNum":" 1802","line":""},
{"lineNum":" 1803","line":"      iterator"},
{"lineNum":" 1804","line":"      _M_erase(iterator __first, iterator __last);"},
{"lineNum":" 1805","line":""},
{"lineNum":" 1806","line":"#if __cplusplus >= 201103L"},
{"lineNum":" 1807","line":"    private:"},
{"lineNum":" 1808","line":"      // Constant-time move assignment when source object\'s memory can be"},
{"lineNum":" 1809","line":"      // moved, either because the source\'s allocator will move too"},
{"lineNum":" 1810","line":"      // or because the allocators are equal."},
{"lineNum":" 1811","line":"      void"},
{"lineNum":" 1812","line":"      _M_move_assign(vector&& __x, true_type) noexcept"},
{"lineNum":" 1813","line":"      {"},
{"lineNum":" 1814","line":"\tvector __tmp(get_allocator());"},
{"lineNum":" 1815","line":"\tthis->_M_impl._M_swap_data(__x._M_impl);"},
{"lineNum":" 1816","line":"\t__tmp._M_impl._M_swap_data(__x._M_impl);"},
{"lineNum":" 1817","line":"\tstd::__alloc_on_move(_M_get_Tp_allocator(), __x._M_get_Tp_allocator());"},
{"lineNum":" 1818","line":"      }"},
{"lineNum":" 1819","line":""},
{"lineNum":" 1820","line":"      // Do move assignment when it might not be possible to move source"},
{"lineNum":" 1821","line":"      // object\'s memory, resulting in a linear-time operation."},
{"lineNum":" 1822","line":"      void"},
{"lineNum":" 1823","line":"      _M_move_assign(vector&& __x, false_type)"},
{"lineNum":" 1824","line":"      {"},
{"lineNum":" 1825","line":"\tif (__x._M_get_Tp_allocator() == this->_M_get_Tp_allocator())"},
{"lineNum":" 1826","line":"\t  _M_move_assign(std::move(__x), true_type());"},
{"lineNum":" 1827","line":"\telse"},
{"lineNum":" 1828","line":"\t  {"},
{"lineNum":" 1829","line":"\t    // The rvalue\'s allocator cannot be moved and is not equal,"},
{"lineNum":" 1830","line":"\t    // so we need to individually move each element."},
{"lineNum":" 1831","line":"\t    this->assign(std::__make_move_if_noexcept_iterator(__x.begin()),"},
{"lineNum":" 1832","line":"\t\t\t std::__make_move_if_noexcept_iterator(__x.end()));"},
{"lineNum":" 1833","line":"\t    __x.clear();"},
{"lineNum":" 1834","line":"\t  }"},
{"lineNum":" 1835","line":"      }"},
{"lineNum":" 1836","line":"#endif"},
{"lineNum":" 1837","line":""},
{"lineNum":" 1838","line":"      template<typename _Up>"},
{"lineNum":" 1839","line":"\t_Up*"},
{"lineNum":" 1840","line":"\t_M_data_ptr(_Up* __ptr) const _GLIBCXX_NOEXCEPT","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 1841","line":"\t{ return __ptr; }","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":" 1842","line":""},
{"lineNum":" 1843","line":"#if __cplusplus >= 201103L"},
{"lineNum":" 1844","line":"      template<typename _Ptr>"},
{"lineNum":" 1845","line":"\ttypename std::pointer_traits<_Ptr>::element_type*"},
{"lineNum":" 1846","line":"\t_M_data_ptr(_Ptr __ptr) const"},
{"lineNum":" 1847","line":"\t{ return empty() ? nullptr : std::__to_address(__ptr); }"},
{"lineNum":" 1848","line":"#else"},
{"lineNum":" 1849","line":"      template<typename _Up>"},
{"lineNum":" 1850","line":"\t_Up*"},
{"lineNum":" 1851","line":"\t_M_data_ptr(_Up* __ptr) _GLIBCXX_NOEXCEPT"},
{"lineNum":" 1852","line":"\t{ return __ptr; }"},
{"lineNum":" 1853","line":""},
{"lineNum":" 1854","line":"      template<typename _Ptr>"},
{"lineNum":" 1855","line":"\tvalue_type*"},
{"lineNum":" 1856","line":"\t_M_data_ptr(_Ptr __ptr)"},
{"lineNum":" 1857","line":"\t{ return empty() ? (value_type*)0 : __ptr.operator->(); }"},
{"lineNum":" 1858","line":""},
{"lineNum":" 1859","line":"      template<typename _Ptr>"},
{"lineNum":" 1860","line":"\tconst value_type*"},
{"lineNum":" 1861","line":"\t_M_data_ptr(_Ptr __ptr) const"},
{"lineNum":" 1862","line":"\t{ return empty() ? (const value_type*)0 : __ptr.operator->(); }"},
{"lineNum":" 1863","line":"#endif"},
{"lineNum":" 1864","line":"    };"},
{"lineNum":" 1865","line":""},
{"lineNum":" 1866","line":"#if __cpp_deduction_guides >= 201606"},
{"lineNum":" 1867","line":"  template<typename _InputIterator, typename _ValT"},
{"lineNum":" 1868","line":"\t     = typename iterator_traits<_InputIterator>::value_type,"},
{"lineNum":" 1869","line":"\t   typename _Allocator = allocator<_ValT>,"},
{"lineNum":" 1870","line":"\t   typename = _RequireInputIter<_InputIterator>,"},
{"lineNum":" 1871","line":"\t   typename = _RequireAllocator<_Allocator>>"},
{"lineNum":" 1872","line":"    vector(_InputIterator, _InputIterator, _Allocator = _Allocator())"},
{"lineNum":" 1873","line":"      -> vector<_ValT, _Allocator>;"},
{"lineNum":" 1874","line":"#endif"},
{"lineNum":" 1875","line":""},
{"lineNum":" 1876","line":"  /**"},
{"lineNum":" 1877","line":"   *  @brief  Vector equality comparison."},
{"lineNum":" 1878","line":"   *  @param  __x  A %vector."},
{"lineNum":" 1879","line":"   *  @param  __y  A %vector of the same type as @a __x."},
{"lineNum":" 1880","line":"   *  @return  True iff the size and elements of the vectors are equal."},
{"lineNum":" 1881","line":"   *"},
{"lineNum":" 1882","line":"   *  This is an equivalence relation.  It is linear in the size of the"},
{"lineNum":" 1883","line":"   *  vectors.  Vectors are considered equivalent if their sizes are equal,"},
{"lineNum":" 1884","line":"   *  and if corresponding elements compare equal."},
{"lineNum":" 1885","line":"  */"},
{"lineNum":" 1886","line":"  template<typename _Tp, typename _Alloc>"},
{"lineNum":" 1887","line":"    inline bool"},
{"lineNum":" 1888","line":"    operator==(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 1889","line":"    { return (__x.size() == __y.size()","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 1890","line":"\t      && std::equal(__x.begin(), __x.end(), __y.begin())); }","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":" 1891","line":""},
{"lineNum":" 1892","line":"  /**"},
{"lineNum":" 1893","line":"   *  @brief  Vector ordering relation."},
{"lineNum":" 1894","line":"   *  @param  __x  A %vector."},
{"lineNum":" 1895","line":"   *  @param  __y  A %vector of the same type as @a __x."},
{"lineNum":" 1896","line":"   *  @return  True iff @a __x is lexicographically less than @a __y."},
{"lineNum":" 1897","line":"   *"},
{"lineNum":" 1898","line":"   *  This is a total ordering relation.  It is linear in the size of the"},
{"lineNum":" 1899","line":"   *  vectors.  The elements must be comparable with @c <."},
{"lineNum":" 1900","line":"   *"},
{"lineNum":" 1901","line":"   *  See std::lexicographical_compare() for how the determination is made."},
{"lineNum":" 1902","line":"  */"},
{"lineNum":" 1903","line":"  template<typename _Tp, typename _Alloc>"},
{"lineNum":" 1904","line":"    inline bool"},
{"lineNum":" 1905","line":"    operator<(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)"},
{"lineNum":" 1906","line":"    { return std::lexicographical_compare(__x.begin(), __x.end(),"},
{"lineNum":" 1907","line":"\t\t\t\t\t  __y.begin(), __y.end()); }"},
{"lineNum":" 1908","line":""},
{"lineNum":" 1909","line":"  /// Based on operator=="},
{"lineNum":" 1910","line":"  template<typename _Tp, typename _Alloc>"},
{"lineNum":" 1911","line":"    inline bool"},
{"lineNum":" 1912","line":"    operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)"},
{"lineNum":" 1913","line":"    { return !(__x == __y); }"},
{"lineNum":" 1914","line":""},
{"lineNum":" 1915","line":"  /// Based on operator<"},
{"lineNum":" 1916","line":"  template<typename _Tp, typename _Alloc>"},
{"lineNum":" 1917","line":"    inline bool"},
{"lineNum":" 1918","line":"    operator>(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)"},
{"lineNum":" 1919","line":"    { return __y < __x; }"},
{"lineNum":" 1920","line":""},
{"lineNum":" 1921","line":"  /// Based on operator<"},
{"lineNum":" 1922","line":"  template<typename _Tp, typename _Alloc>"},
{"lineNum":" 1923","line":"    inline bool"},
{"lineNum":" 1924","line":"    operator<=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)"},
{"lineNum":" 1925","line":"    { return !(__y < __x); }"},
{"lineNum":" 1926","line":""},
{"lineNum":" 1927","line":"  /// Based on operator<"},
{"lineNum":" 1928","line":"  template<typename _Tp, typename _Alloc>"},
{"lineNum":" 1929","line":"    inline bool"},
{"lineNum":" 1930","line":"    operator>=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)"},
{"lineNum":" 1931","line":"    { return !(__x < __y); }"},
{"lineNum":" 1932","line":""},
{"lineNum":" 1933","line":"  /// See std::vector::swap()."},
{"lineNum":" 1934","line":"  template<typename _Tp, typename _Alloc>"},
{"lineNum":" 1935","line":"    inline void"},
{"lineNum":" 1936","line":"    swap(vector<_Tp, _Alloc>& __x, vector<_Tp, _Alloc>& __y)"},
{"lineNum":" 1937","line":"    _GLIBCXX_NOEXCEPT_IF(noexcept(__x.swap(__y)))"},
{"lineNum":" 1938","line":"    { __x.swap(__y); }"},
{"lineNum":" 1939","line":""},
{"lineNum":" 1940","line":"_GLIBCXX_END_NAMESPACE_CONTAINER"},
{"lineNum":" 1941","line":""},
{"lineNum":" 1942","line":"#if __cplusplus >= 201703L"},
{"lineNum":" 1943","line":"  namespace __detail::__variant"},
{"lineNum":" 1944","line":"  {"},
{"lineNum":" 1945","line":"    template<typename> struct _Never_valueless_alt; // see <variant>"},
{"lineNum":" 1946","line":""},
{"lineNum":" 1947","line":"    // Provide the strong exception-safety guarantee when emplacing a"},
{"lineNum":" 1948","line":"    // vector into a variant, but only if move assignment cannot throw."},
{"lineNum":" 1949","line":"    template<typename _Tp, typename _Alloc>"},
{"lineNum":" 1950","line":"      struct _Never_valueless_alt<_GLIBCXX_STD_C::vector<_Tp, _Alloc>>"},
{"lineNum":" 1951","line":"      : std::is_nothrow_move_assignable<_GLIBCXX_STD_C::vector<_Tp, _Alloc>>"},
{"lineNum":" 1952","line":"      { };"},
{"lineNum":" 1953","line":"  }  // namespace __detail::__variant"},
{"lineNum":" 1954","line":"#endif // C++17"},
{"lineNum":" 1955","line":""},
{"lineNum":" 1956","line":"_GLIBCXX_END_NAMESPACE_VERSION"},
{"lineNum":" 1957","line":"} // namespace std"},
{"lineNum":" 1958","line":""},
{"lineNum":" 1959","line":"#endif /* _STL_VECTOR_H */"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "bech32_fuzz_2_gcc_instrumented", "date" : "2023-07-28 14:53:55", "instrumented" : 180, "covered" : 1,};
var merged_data = [];
