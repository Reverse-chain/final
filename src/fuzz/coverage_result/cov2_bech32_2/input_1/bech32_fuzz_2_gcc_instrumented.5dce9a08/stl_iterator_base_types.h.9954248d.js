var data = {lines:[
{"lineNum":"    1","line":"// Types used in iterator implementation -*- C++ -*-"},
{"lineNum":"    2","line":""},
{"lineNum":"    3","line":"// Copyright (C) 2001-2019 Free Software Foundation, Inc."},
{"lineNum":"    4","line":"//"},
{"lineNum":"    5","line":"// This file is part of the GNU ISO C++ Library.  This library is free"},
{"lineNum":"    6","line":"// software; you can redistribute it and/or modify it under the"},
{"lineNum":"    7","line":"// terms of the GNU General Public License as published by the"},
{"lineNum":"    8","line":"// Free Software Foundation; either version 3, or (at your option)"},
{"lineNum":"    9","line":"// any later version."},
{"lineNum":"   10","line":""},
{"lineNum":"   11","line":"// This library is distributed in the hope that it will be useful,"},
{"lineNum":"   12","line":"// but WITHOUT ANY WARRANTY; without even the implied warranty of"},
{"lineNum":"   13","line":"// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the"},
{"lineNum":"   14","line":"// GNU General Public License for more details."},
{"lineNum":"   15","line":""},
{"lineNum":"   16","line":"// Under Section 7 of GPL version 3, you are granted additional"},
{"lineNum":"   17","line":"// permissions described in the GCC Runtime Library Exception, version"},
{"lineNum":"   18","line":"// 3.1, as published by the Free Software Foundation."},
{"lineNum":"   19","line":""},
{"lineNum":"   20","line":"// You should have received a copy of the GNU General Public License and"},
{"lineNum":"   21","line":"// a copy of the GCC Runtime Library Exception along with this program;"},
{"lineNum":"   22","line":"// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see"},
{"lineNum":"   23","line":"// <http://www.gnu.org/licenses/>."},
{"lineNum":"   24","line":""},
{"lineNum":"   25","line":"/*"},
{"lineNum":"   26","line":" *"},
{"lineNum":"   27","line":" * Copyright (c) 1994"},
{"lineNum":"   28","line":" * Hewlett-Packard Company"},
{"lineNum":"   29","line":" *"},
{"lineNum":"   30","line":" * Permission to use, copy, modify, distribute and sell this software"},
{"lineNum":"   31","line":" * and its documentation for any purpose is hereby granted without fee,"},
{"lineNum":"   32","line":" * provided that the above copyright notice appear in all copies and"},
{"lineNum":"   33","line":" * that both that copyright notice and this permission notice appear"},
{"lineNum":"   34","line":" * in supporting documentation.  Hewlett-Packard Company makes no"},
{"lineNum":"   35","line":" * representations about the suitability of this software for any"},
{"lineNum":"   36","line":" * purpose.  It is provided \"as is\" without express or implied warranty."},
{"lineNum":"   37","line":" *"},
{"lineNum":"   38","line":" *"},
{"lineNum":"   39","line":" * Copyright (c) 1996-1998"},
{"lineNum":"   40","line":" * Silicon Graphics Computer Systems, Inc."},
{"lineNum":"   41","line":" *"},
{"lineNum":"   42","line":" * Permission to use, copy, modify, distribute and sell this software"},
{"lineNum":"   43","line":" * and its documentation for any purpose is hereby granted without fee,"},
{"lineNum":"   44","line":" * provided that the above copyright notice appear in all copies and"},
{"lineNum":"   45","line":" * that both that copyright notice and this permission notice appear"},
{"lineNum":"   46","line":" * in supporting documentation.  Silicon Graphics makes no"},
{"lineNum":"   47","line":" * representations about the suitability of this software for any"},
{"lineNum":"   48","line":" * purpose.  It is provided \"as is\" without express or implied warranty."},
{"lineNum":"   49","line":" */"},
{"lineNum":"   50","line":""},
{"lineNum":"   51","line":"/** @file bits/stl_iterator_base_types.h"},
{"lineNum":"   52","line":" *  This is an internal header file, included by other library headers."},
{"lineNum":"   53","line":" *  Do not attempt to use it directly. @headername{iterator}"},
{"lineNum":"   54","line":" *"},
{"lineNum":"   55","line":" *  This file contains all of the general iterator-related utility types,"},
{"lineNum":"   56","line":" *  such as iterator_traits and struct iterator."},
{"lineNum":"   57","line":" */"},
{"lineNum":"   58","line":""},
{"lineNum":"   59","line":"#ifndef _STL_ITERATOR_BASE_TYPES_H"},
{"lineNum":"   60","line":"#define _STL_ITERATOR_BASE_TYPES_H 1"},
{"lineNum":"   61","line":""},
{"lineNum":"   62","line":"#pragma GCC system_header"},
{"lineNum":"   63","line":""},
{"lineNum":"   64","line":"#include <bits/c++config.h>"},
{"lineNum":"   65","line":""},
{"lineNum":"   66","line":"#if __cplusplus >= 201103L"},
{"lineNum":"   67","line":"# include <type_traits>  // For __void_t, is_convertible"},
{"lineNum":"   68","line":"#endif"},
{"lineNum":"   69","line":""},
{"lineNum":"   70","line":"namespace std _GLIBCXX_VISIBILITY(default)"},
{"lineNum":"   71","line":"{"},
{"lineNum":"   72","line":"_GLIBCXX_BEGIN_NAMESPACE_VERSION"},
{"lineNum":"   73","line":""},
{"lineNum":"   74","line":"  /**"},
{"lineNum":"   75","line":"   *  @defgroup iterators Iterators"},
{"lineNum":"   76","line":"   *  Abstractions for uniform iterating through various underlying types."},
{"lineNum":"   77","line":"  */"},
{"lineNum":"   78","line":"  ///@{"},
{"lineNum":"   79","line":""},
{"lineNum":"   80","line":"  /**"},
{"lineNum":"   81","line":"   *  @defgroup iterator_tags Iterator Tags"},
{"lineNum":"   82","line":"   *  These are empty types, used to distinguish different iterators.  The"},
{"lineNum":"   83","line":"   *  distinction is not made by what they contain, but simply by what they"},
{"lineNum":"   84","line":"   *  are.  Different underlying algorithms can then be used based on the"},
{"lineNum":"   85","line":"   *  different operations supported by different iterator types."},
{"lineNum":"   86","line":"  */"},
{"lineNum":"   87","line":"  ///@{"},
{"lineNum":"   88","line":"  ///  Marking input iterators."},
{"lineNum":"   89","line":"  struct input_iterator_tag { };"},
{"lineNum":"   90","line":""},
{"lineNum":"   91","line":"  ///  Marking output iterators."},
{"lineNum":"   92","line":"  struct output_iterator_tag { };"},
{"lineNum":"   93","line":""},
{"lineNum":"   94","line":"  /// Forward iterators support a superset of input iterator operations."},
{"lineNum":"   95","line":"  struct forward_iterator_tag : public input_iterator_tag { };"},
{"lineNum":"   96","line":""},
{"lineNum":"   97","line":"  /// Bidirectional iterators support a superset of forward iterator"},
{"lineNum":"   98","line":"  /// operations."},
{"lineNum":"   99","line":"  struct bidirectional_iterator_tag : public forward_iterator_tag { };"},
{"lineNum":"  100","line":""},
{"lineNum":"  101","line":"  /// Random-access iterators support a superset of bidirectional"},
{"lineNum":"  102","line":"  /// iterator operations."},
{"lineNum":"  103","line":"  struct random_access_iterator_tag : public bidirectional_iterator_tag { };"},
{"lineNum":"  104","line":"  ///@}"},
{"lineNum":"  105","line":""},
{"lineNum":"  106","line":"  /**"},
{"lineNum":"  107","line":"   *  @brief  Common %iterator class."},
{"lineNum":"  108","line":"   *"},
{"lineNum":"  109","line":"   *  This class does nothing but define nested typedefs.  %Iterator classes"},
{"lineNum":"  110","line":"   *  can inherit from this class to save some work.  The typedefs are then"},
{"lineNum":"  111","line":"   *  used in specializations and overloading."},
{"lineNum":"  112","line":"   *"},
{"lineNum":"  113","line":"   *  In particular, there are no default implementations of requirements"},
{"lineNum":"  114","line":"   *  such as @c operator++ and the like.  (How could there be?)"},
{"lineNum":"  115","line":"  */"},
{"lineNum":"  116","line":"  template<typename _Category, typename _Tp, typename _Distance = ptrdiff_t,"},
{"lineNum":"  117","line":"           typename _Pointer = _Tp*, typename _Reference = _Tp&>"},
{"lineNum":"  118","line":"    struct iterator"},
{"lineNum":"  119","line":"    {"},
{"lineNum":"  120","line":"      /// One of the @link iterator_tags tag types@endlink."},
{"lineNum":"  121","line":"      typedef _Category  iterator_category;"},
{"lineNum":"  122","line":"      /// The type \"pointed to\" by the iterator."},
{"lineNum":"  123","line":"      typedef _Tp        value_type;"},
{"lineNum":"  124","line":"      /// Distance between iterators is represented as this type."},
{"lineNum":"  125","line":"      typedef _Distance  difference_type;"},
{"lineNum":"  126","line":"      /// This type represents a pointer-to-value_type."},
{"lineNum":"  127","line":"      typedef _Pointer   pointer;"},
{"lineNum":"  128","line":"      /// This type represents a reference-to-value_type."},
{"lineNum":"  129","line":"      typedef _Reference reference;"},
{"lineNum":"  130","line":"    };"},
{"lineNum":"  131","line":""},
{"lineNum":"  132","line":"  /**"},
{"lineNum":"  133","line":"   *  @brief  Traits class for iterators."},
{"lineNum":"  134","line":"   *"},
{"lineNum":"  135","line":"   *  This class does nothing but define nested typedefs.  The general"},
{"lineNum":"  136","line":"   *  version simply @a forwards the nested typedefs from the Iterator"},
{"lineNum":"  137","line":"   *  argument.  Specialized versions for pointers and pointers-to-const"},
{"lineNum":"  138","line":"   *  provide tighter, more correct semantics."},
{"lineNum":"  139","line":"  */"},
{"lineNum":"  140","line":"#if __cplusplus >= 201103L"},
{"lineNum":"  141","line":"  // _GLIBCXX_RESOLVE_LIB_DEFECTS"},
{"lineNum":"  142","line":"  // 2408. SFINAE-friendly common_type/iterator_traits is missing in C++14"},
{"lineNum":"  143","line":"  template<typename _Iterator, typename = __void_t<>>"},
{"lineNum":"  144","line":"    struct __iterator_traits { };"},
{"lineNum":"  145","line":""},
{"lineNum":"  146","line":"  template<typename _Iterator>"},
{"lineNum":"  147","line":"    struct __iterator_traits<_Iterator,"},
{"lineNum":"  148","line":"\t\t\t     __void_t<typename _Iterator::iterator_category,"},
{"lineNum":"  149","line":"\t\t\t\t      typename _Iterator::value_type,"},
{"lineNum":"  150","line":"\t\t\t\t      typename _Iterator::difference_type,"},
{"lineNum":"  151","line":"\t\t\t\t      typename _Iterator::pointer,"},
{"lineNum":"  152","line":"\t\t\t\t      typename _Iterator::reference>>"},
{"lineNum":"  153","line":"    {"},
{"lineNum":"  154","line":"      typedef typename _Iterator::iterator_category iterator_category;"},
{"lineNum":"  155","line":"      typedef typename _Iterator::value_type        value_type;"},
{"lineNum":"  156","line":"      typedef typename _Iterator::difference_type   difference_type;"},
{"lineNum":"  157","line":"      typedef typename _Iterator::pointer           pointer;"},
{"lineNum":"  158","line":"      typedef typename _Iterator::reference         reference;"},
{"lineNum":"  159","line":"    };"},
{"lineNum":"  160","line":""},
{"lineNum":"  161","line":"  template<typename _Iterator>"},
{"lineNum":"  162","line":"    struct iterator_traits"},
{"lineNum":"  163","line":"    : public __iterator_traits<_Iterator> { };"},
{"lineNum":"  164","line":"#else"},
{"lineNum":"  165","line":"  template<typename _Iterator>"},
{"lineNum":"  166","line":"    struct iterator_traits"},
{"lineNum":"  167","line":"    {"},
{"lineNum":"  168","line":"      typedef typename _Iterator::iterator_category iterator_category;"},
{"lineNum":"  169","line":"      typedef typename _Iterator::value_type        value_type;"},
{"lineNum":"  170","line":"      typedef typename _Iterator::difference_type   difference_type;"},
{"lineNum":"  171","line":"      typedef typename _Iterator::pointer           pointer;"},
{"lineNum":"  172","line":"      typedef typename _Iterator::reference         reference;"},
{"lineNum":"  173","line":"    };"},
{"lineNum":"  174","line":"#endif"},
{"lineNum":"  175","line":""},
{"lineNum":"  176","line":"  /// Partial specialization for pointer types."},
{"lineNum":"  177","line":"  template<typename _Tp>"},
{"lineNum":"  178","line":"    struct iterator_traits<_Tp*>"},
{"lineNum":"  179","line":"    {"},
{"lineNum":"  180","line":"      typedef random_access_iterator_tag iterator_category;"},
{"lineNum":"  181","line":"      typedef _Tp                         value_type;"},
{"lineNum":"  182","line":"      typedef ptrdiff_t                   difference_type;"},
{"lineNum":"  183","line":"      typedef _Tp*                        pointer;"},
{"lineNum":"  184","line":"      typedef _Tp&                        reference;"},
{"lineNum":"  185","line":"    };"},
{"lineNum":"  186","line":""},
{"lineNum":"  187","line":"  /// Partial specialization for const pointer types."},
{"lineNum":"  188","line":"  template<typename _Tp>"},
{"lineNum":"  189","line":"    struct iterator_traits<const _Tp*>"},
{"lineNum":"  190","line":"    {"},
{"lineNum":"  191","line":"      typedef random_access_iterator_tag iterator_category;"},
{"lineNum":"  192","line":"      typedef _Tp                         value_type;"},
{"lineNum":"  193","line":"      typedef ptrdiff_t                   difference_type;"},
{"lineNum":"  194","line":"      typedef const _Tp*                  pointer;"},
{"lineNum":"  195","line":"      typedef const _Tp&                  reference;"},
{"lineNum":"  196","line":"    };"},
{"lineNum":"  197","line":""},
{"lineNum":"  198","line":"  /**"},
{"lineNum":"  199","line":"   *  This function is not a part of the C++ standard but is syntactic"},
{"lineNum":"  200","line":"   *  sugar for internal library use only."},
{"lineNum":"  201","line":"  */"},
{"lineNum":"  202","line":"  template<typename _Iter>"},
{"lineNum":"  203","line":"    inline _GLIBCXX_CONSTEXPR"},
{"lineNum":"  204","line":"    typename iterator_traits<_Iter>::iterator_category"},
{"lineNum":"  205","line":"    __iterator_category(const _Iter&)","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  206","line":"    { return typename iterator_traits<_Iter>::iterator_category(); }","class":"lineNoCov","hits":"0","possible_hits":"6",},
{"lineNum":"  207","line":""},
{"lineNum":"  208","line":"  ///@}"},
{"lineNum":"  209","line":""},
{"lineNum":"  210","line":"#if __cplusplus < 201103L"},
{"lineNum":"  211","line":"  // If _Iterator has a base returns it otherwise _Iterator is returned"},
{"lineNum":"  212","line":"  // untouched"},
{"lineNum":"  213","line":"  template<typename _Iterator, bool _HasBase>"},
{"lineNum":"  214","line":"    struct _Iter_base"},
{"lineNum":"  215","line":"    {"},
{"lineNum":"  216","line":"      typedef _Iterator iterator_type;"},
{"lineNum":"  217","line":"      static iterator_type _S_base(_Iterator __it)"},
{"lineNum":"  218","line":"      { return __it; }"},
{"lineNum":"  219","line":"    };"},
{"lineNum":"  220","line":""},
{"lineNum":"  221","line":"  template<typename _Iterator>"},
{"lineNum":"  222","line":"    struct _Iter_base<_Iterator, true>"},
{"lineNum":"  223","line":"    {"},
{"lineNum":"  224","line":"      typedef typename _Iterator::iterator_type iterator_type;"},
{"lineNum":"  225","line":"      static iterator_type _S_base(_Iterator __it)"},
{"lineNum":"  226","line":"      { return __it.base(); }"},
{"lineNum":"  227","line":"    };"},
{"lineNum":"  228","line":"#endif"},
{"lineNum":"  229","line":""},
{"lineNum":"  230","line":"#if __cplusplus >= 201103L"},
{"lineNum":"  231","line":"  template<typename _InIter>"},
{"lineNum":"  232","line":"    using _RequireInputIter = typename"},
{"lineNum":"  233","line":"      enable_if<is_convertible<typename"},
{"lineNum":"  234","line":"\t\titerator_traits<_InIter>::iterator_category,"},
{"lineNum":"  235","line":"\t\t\t       input_iterator_tag>::value>::type;"},
{"lineNum":"  236","line":"#endif"},
{"lineNum":"  237","line":""},
{"lineNum":"  238","line":"_GLIBCXX_END_NAMESPACE_VERSION"},
{"lineNum":"  239","line":"} // namespace"},
{"lineNum":"  240","line":""},
{"lineNum":"  241","line":"#endif /* _STL_ITERATOR_BASE_TYPES_H */"},
{"lineNum":"  242","line":""},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "bech32_fuzz_2_gcc_instrumented", "date" : "2023-07-28 14:53:55", "instrumented" : 2, "covered" : 0,};
var merged_data = [];
