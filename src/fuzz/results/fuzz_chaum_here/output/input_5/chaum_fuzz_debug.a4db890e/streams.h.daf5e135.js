var data = {lines:[
{"lineNum":"    1","line":"// Copyright (c) 2009-2010 Satoshi Nakamoto"},
{"lineNum":"    2","line":"// Copyright (c) 2009-2016 The Bitcoin Core developers"},
{"lineNum":"    3","line":"// Distributed under the MIT software license, see the accompanying"},
{"lineNum":"    4","line":"// file COPYING or http://www.opensource.org/licenses/mit-license.php."},
{"lineNum":"    5","line":""},
{"lineNum":"    6","line":"#ifndef BITCOIN_STREAMS_H"},
{"lineNum":"    7","line":"#define BITCOIN_STREAMS_H"},
{"lineNum":"    8","line":""},
{"lineNum":"    9","line":"#include \"support/allocators/zeroafterfree.h\""},
{"lineNum":"   10","line":"#include \"serialize.h\""},
{"lineNum":"   11","line":""},
{"lineNum":"   12","line":"#include <algorithm>"},
{"lineNum":"   13","line":"#include <assert.h>"},
{"lineNum":"   14","line":"#include <ios>"},
{"lineNum":"   15","line":"#include <limits>"},
{"lineNum":"   16","line":"#include <map>"},
{"lineNum":"   17","line":"#include <set>"},
{"lineNum":"   18","line":"#include <stdint.h>"},
{"lineNum":"   19","line":"#include <stdio.h>"},
{"lineNum":"   20","line":"#include <string>"},
{"lineNum":"   21","line":"#include <string.h>"},
{"lineNum":"   22","line":"#include <utility>"},
{"lineNum":"   23","line":"#include <vector>"},
{"lineNum":"   24","line":""},
{"lineNum":"   25","line":"template<typename Stream>"},
{"lineNum":"   26","line":"class OverrideStream"},
{"lineNum":"   27","line":"{"},
{"lineNum":"   28","line":"    Stream* stream;"},
{"lineNum":"   29","line":""},
{"lineNum":"   30","line":"    const int nType;"},
{"lineNum":"   31","line":"    const int nVersion;"},
{"lineNum":"   32","line":""},
{"lineNum":"   33","line":"public:"},
{"lineNum":"   34","line":"    OverrideStream(Stream* stream_, int nType_, int nVersion_) : stream(stream_), nType(nType_), nVersion(nVersion_) {}"},
{"lineNum":"   35","line":""},
{"lineNum":"   36","line":"    template<typename T>"},
{"lineNum":"   37","line":"    OverrideStream<Stream>& operator<<(const T& obj)"},
{"lineNum":"   38","line":"    {"},
{"lineNum":"   39","line":"        // Serialize to this stream"},
{"lineNum":"   40","line":"        ::Serialize(*this, obj);"},
{"lineNum":"   41","line":"        return (*this);"},
{"lineNum":"   42","line":"    }"},
{"lineNum":"   43","line":""},
{"lineNum":"   44","line":"    template<typename T>"},
{"lineNum":"   45","line":"    OverrideStream<Stream>& operator>>(T& obj)"},
{"lineNum":"   46","line":"    {"},
{"lineNum":"   47","line":"        // Unserialize from this stream"},
{"lineNum":"   48","line":"        ::Unserialize(*this, obj);"},
{"lineNum":"   49","line":"        return (*this);"},
{"lineNum":"   50","line":"    }"},
{"lineNum":"   51","line":""},
{"lineNum":"   52","line":"    void write(const char* pch, size_t nSize)"},
{"lineNum":"   53","line":"    {"},
{"lineNum":"   54","line":"        stream->write(pch, nSize);"},
{"lineNum":"   55","line":"    }"},
{"lineNum":"   56","line":""},
{"lineNum":"   57","line":"    void read(char* pch, size_t nSize)"},
{"lineNum":"   58","line":"    {"},
{"lineNum":"   59","line":"        stream->read(pch, nSize);"},
{"lineNum":"   60","line":"    }"},
{"lineNum":"   61","line":""},
{"lineNum":"   62","line":"    int GetVersion() const { return nVersion; }"},
{"lineNum":"   63","line":"    int GetType() const { return nType; }"},
{"lineNum":"   64","line":"};"},
{"lineNum":"   65","line":""},
{"lineNum":"   66","line":"template<typename S>"},
{"lineNum":"   67","line":"OverrideStream<S> WithOrVersion(S* s, int nVersionFlag)"},
{"lineNum":"   68","line":"{"},
{"lineNum":"   69","line":"    return OverrideStream<S>(s, s->GetType(), s->GetVersion() | nVersionFlag);"},
{"lineNum":"   70","line":"}"},
{"lineNum":"   71","line":""},
{"lineNum":"   72","line":"/* Minimal stream for overwriting and/or appending to an existing byte vector"},
{"lineNum":"   73","line":" *"},
{"lineNum":"   74","line":" * The referenced vector will grow as necessary"},
{"lineNum":"   75","line":" */"},
{"lineNum":"   76","line":"class CVectorWriter"},
{"lineNum":"   77","line":"{"},
{"lineNum":"   78","line":" public:"},
{"lineNum":"   79","line":""},
{"lineNum":"   80","line":"/*"},
{"lineNum":"   81","line":" * @param[in]  nTypeIn Serialization Type"},
{"lineNum":"   82","line":" * @param[in]  nVersionIn Serialization Version (including any flags)"},
{"lineNum":"   83","line":" * @param[in]  vchDataIn  Referenced byte vector to overwrite/append"},
{"lineNum":"   84","line":" * @param[in]  nPosIn Starting position. Vector index where writes should start. The vector will initially"},
{"lineNum":"   85","line":" *                    grow as necessary to  max(index, vec.size()). So to append, use vec.size()."},
{"lineNum":"   86","line":"*/"},
{"lineNum":"   87","line":"    CVectorWriter(int nTypeIn, int nVersionIn, std::vector<unsigned char>& vchDataIn, size_t nPosIn) : nType(nTypeIn), nVersion(nVersionIn), vchData(vchDataIn), nPos(nPosIn)"},
{"lineNum":"   88","line":"    {"},
{"lineNum":"   89","line":"        if(nPos > vchData.size())"},
{"lineNum":"   90","line":"            vchData.resize(nPos);"},
{"lineNum":"   91","line":"    }"},
{"lineNum":"   92","line":"/*"},
{"lineNum":"   93","line":" * (other params same as above)"},
{"lineNum":"   94","line":" * @param[in]  args  A list of items to serialize starting at nPos."},
{"lineNum":"   95","line":"*/"},
{"lineNum":"   96","line":"    template <typename... Args>"},
{"lineNum":"   97","line":"    CVectorWriter(int nTypeIn, int nVersionIn, std::vector<unsigned char>& vchDataIn, size_t nPosIn, Args&&... args) : CVectorWriter(nTypeIn, nVersionIn, vchDataIn, nPosIn)"},
{"lineNum":"   98","line":"    {"},
{"lineNum":"   99","line":"        ::SerializeMany(*this, std::forward<Args>(args)...);"},
{"lineNum":"  100","line":"    }"},
{"lineNum":"  101","line":"    void write(const char* pch, size_t nSize)"},
{"lineNum":"  102","line":"    {"},
{"lineNum":"  103","line":"        assert(nPos <= vchData.size());"},
{"lineNum":"  104","line":"        size_t nOverwrite = std::min(nSize, vchData.size() - nPos);"},
{"lineNum":"  105","line":"        if (nOverwrite) {"},
{"lineNum":"  106","line":"            memcpy(vchData.data() + nPos, reinterpret_cast<const unsigned char*>(pch), nOverwrite);"},
{"lineNum":"  107","line":"        }"},
{"lineNum":"  108","line":"        if (nOverwrite < nSize) {"},
{"lineNum":"  109","line":"            vchData.insert(vchData.end(), reinterpret_cast<const unsigned char*>(pch) + nOverwrite, reinterpret_cast<const unsigned char*>(pch) + nSize);"},
{"lineNum":"  110","line":"        }"},
{"lineNum":"  111","line":"        nPos += nSize;"},
{"lineNum":"  112","line":"    }"},
{"lineNum":"  113","line":"    template<typename T>"},
{"lineNum":"  114","line":"    CVectorWriter& operator<<(const T& obj)"},
{"lineNum":"  115","line":"    {"},
{"lineNum":"  116","line":"        // Serialize to this stream"},
{"lineNum":"  117","line":"        ::Serialize(*this, obj);"},
{"lineNum":"  118","line":"        return (*this);"},
{"lineNum":"  119","line":"    }"},
{"lineNum":"  120","line":"    int GetVersion() const"},
{"lineNum":"  121","line":"    {"},
{"lineNum":"  122","line":"        return nVersion;"},
{"lineNum":"  123","line":"    }"},
{"lineNum":"  124","line":"    int GetType() const"},
{"lineNum":"  125","line":"    {"},
{"lineNum":"  126","line":"        return nType;"},
{"lineNum":"  127","line":"    }"},
{"lineNum":"  128","line":"    void seek(size_t nSize)"},
{"lineNum":"  129","line":"    {"},
{"lineNum":"  130","line":"        nPos += nSize;"},
{"lineNum":"  131","line":"        if(nPos > vchData.size())"},
{"lineNum":"  132","line":"            vchData.resize(nPos);"},
{"lineNum":"  133","line":"    }"},
{"lineNum":"  134","line":"private:"},
{"lineNum":"  135","line":"    const int nType;"},
{"lineNum":"  136","line":"    const int nVersion;"},
{"lineNum":"  137","line":"    std::vector<unsigned char>& vchData;"},
{"lineNum":"  138","line":"    size_t nPos;"},
{"lineNum":"  139","line":"};"},
{"lineNum":"  140","line":""},
{"lineNum":"  141","line":"/** Double ended buffer combining vector and stream-like interfaces."},
{"lineNum":"  142","line":" *"},
{"lineNum":"  143","line":" * >> and << read and write unformatted data using the above serialization templates."},
{"lineNum":"  144","line":" * Fills with data in linear time; some stringstream implementations take N^2 time."},
{"lineNum":"  145","line":" */"},
{"lineNum":"  146","line":"class CDataStream","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  147","line":"{"},
{"lineNum":"  148","line":"protected:"},
{"lineNum":"  149","line":"    typedef CSerializeData vector_type;"},
{"lineNum":"  150","line":"    unsigned int nReadPos;"},
{"lineNum":"  151","line":""},
{"lineNum":"  152","line":"    int nType;"},
{"lineNum":"  153","line":"    int nVersion;"},
{"lineNum":"  154","line":"public:"},
{"lineNum":"  155","line":"    vector_type vch;"},
{"lineNum":"  156","line":""},
{"lineNum":"  157","line":"    typedef vector_type::allocator_type   allocator_type;"},
{"lineNum":"  158","line":"    typedef vector_type::size_type        size_type;"},
{"lineNum":"  159","line":"    typedef vector_type::difference_type  difference_type;"},
{"lineNum":"  160","line":"    typedef vector_type::reference        reference;"},
{"lineNum":"  161","line":"    typedef vector_type::const_reference  const_reference;"},
{"lineNum":"  162","line":"    typedef vector_type::value_type       value_type;"},
{"lineNum":"  163","line":"    typedef vector_type::iterator         iterator;"},
{"lineNum":"  164","line":"    typedef vector_type::const_iterator   const_iterator;"},
{"lineNum":"  165","line":"    typedef vector_type::reverse_iterator reverse_iterator;"},
{"lineNum":"  166","line":""},
{"lineNum":"  167","line":"    explicit CDataStream(int nTypeIn, int nVersionIn)","class":"lineCov","hits":"1","order":"1327","possible_hits":"1",},
{"lineNum":"  168","line":"    {","class":"lineCov","hits":"2","order":"1326","possible_hits":"2",},
{"lineNum":"  169","line":"        Init(nTypeIn, nVersionIn);","class":"lineCov","hits":"1","order":"1329","possible_hits":"1",},
{"lineNum":"  170","line":"    }","class":"lineCov","hits":"1","order":"1335","possible_hits":"1",},
{"lineNum":"  171","line":""},
{"lineNum":"  172","line":"    CDataStream(const_iterator pbegin, const_iterator pend, int nTypeIn, int nVersionIn) : vch(pbegin, pend)"},
{"lineNum":"  173","line":"    {"},
{"lineNum":"  174","line":"        Init(nTypeIn, nVersionIn);"},
{"lineNum":"  175","line":"    }"},
{"lineNum":"  176","line":""},
{"lineNum":"  177","line":"    CDataStream(const char* pbegin, const char* pend, int nTypeIn, int nVersionIn) : vch(pbegin, pend)"},
{"lineNum":"  178","line":"    {"},
{"lineNum":"  179","line":"        Init(nTypeIn, nVersionIn);"},
{"lineNum":"  180","line":"    }"},
{"lineNum":"  181","line":""},
{"lineNum":"  182","line":"    CDataStream(const vector_type& vchIn, int nTypeIn, int nVersionIn) : vch(vchIn.begin(), vchIn.end())"},
{"lineNum":"  183","line":"    {"},
{"lineNum":"  184","line":"        Init(nTypeIn, nVersionIn);"},
{"lineNum":"  185","line":"    }"},
{"lineNum":"  186","line":""},
{"lineNum":"  187","line":"    CDataStream(const std::vector<char>& vchIn, int nTypeIn, int nVersionIn) : vch(vchIn.begin(), vchIn.end())"},
{"lineNum":"  188","line":"    {"},
{"lineNum":"  189","line":"        Init(nTypeIn, nVersionIn);"},
{"lineNum":"  190","line":"    }"},
{"lineNum":"  191","line":""},
{"lineNum":"  192","line":"    CDataStream(const std::vector<unsigned char>& vchIn, int nTypeIn, int nVersionIn) : vch(vchIn.begin(), vchIn.end())"},
{"lineNum":"  193","line":"    {"},
{"lineNum":"  194","line":"        Init(nTypeIn, nVersionIn);"},
{"lineNum":"  195","line":"    }"},
{"lineNum":"  196","line":""},
{"lineNum":"  197","line":"    template <typename... Args>"},
{"lineNum":"  198","line":"    CDataStream(int nTypeIn, int nVersionIn, Args&&... args)"},
{"lineNum":"  199","line":"    {"},
{"lineNum":"  200","line":"        Init(nTypeIn, nVersionIn);"},
{"lineNum":"  201","line":"        ::SerializeMany(*this, std::forward<Args>(args)...);"},
{"lineNum":"  202","line":"    }"},
{"lineNum":"  203","line":""},
{"lineNum":"  204","line":"    void Init(int nTypeIn, int nVersionIn)"},
{"lineNum":"  205","line":"    {","class":"lineCov","hits":"2","order":"1330","possible_hits":"2",},
{"lineNum":"  206","line":"        nReadPos = 0;","class":"lineCov","hits":"1","order":"1331","possible_hits":"1",},
{"lineNum":"  207","line":"        nType = nTypeIn;","class":"lineCov","hits":"1","order":"1332","possible_hits":"1",},
{"lineNum":"  208","line":"        nVersion = nVersionIn;","class":"lineCov","hits":"1","order":"1333","possible_hits":"1",},
{"lineNum":"  209","line":"    }","class":"linePartCov","hits":"1","order":"1334","possible_hits":"2",},
{"lineNum":"  210","line":""},
{"lineNum":"  211","line":"    CDataStream& operator+=(const CDataStream& b)"},
{"lineNum":"  212","line":"    {"},
{"lineNum":"  213","line":"        vch.insert(vch.end(), b.begin(), b.end());"},
{"lineNum":"  214","line":"        return *this;"},
{"lineNum":"  215","line":"    }"},
{"lineNum":"  216","line":""},
{"lineNum":"  217","line":"    friend CDataStream operator+(const CDataStream& a, const CDataStream& b)"},
{"lineNum":"  218","line":"    {"},
{"lineNum":"  219","line":"        CDataStream ret = a;"},
{"lineNum":"  220","line":"        ret += b;"},
{"lineNum":"  221","line":"        return (ret);"},
{"lineNum":"  222","line":"    }"},
{"lineNum":"  223","line":""},
{"lineNum":"  224","line":"    std::string str() const"},
{"lineNum":"  225","line":"    {"},
{"lineNum":"  226","line":"        return (std::string(begin(), end()));"},
{"lineNum":"  227","line":"    }"},
{"lineNum":"  228","line":""},
{"lineNum":"  229","line":""},
{"lineNum":"  230","line":"    //"},
{"lineNum":"  231","line":"    // Vector subset"},
{"lineNum":"  232","line":"    //"},
{"lineNum":"  233","line":"    const_iterator begin() const                     { return vch.begin() + nReadPos; }"},
{"lineNum":"  234","line":"    iterator begin()                                 { return vch.begin() + nReadPos; }"},
{"lineNum":"  235","line":"    const_iterator end() const                       { return vch.end(); }"},
{"lineNum":"  236","line":"    iterator end()                                   { return vch.end(); }"},
{"lineNum":"  237","line":"    size_type size() const                           { return vch.size() - nReadPos; }"},
{"lineNum":"  238","line":"    bool empty() const                               { return vch.size() == nReadPos; }"},
{"lineNum":"  239","line":"    void resize(size_type n, value_type c=0)         { vch.resize(n + nReadPos, c); }"},
{"lineNum":"  240","line":"    void reserve(size_type n)                        { vch.reserve(n + nReadPos); }"},
{"lineNum":"  241","line":"    const_reference operator[](size_type pos) const  { return vch[pos + nReadPos]; }"},
{"lineNum":"  242","line":"    reference operator[](size_type pos)              { return vch[pos + nReadPos]; }"},
{"lineNum":"  243","line":"    void clear()                                     { vch.clear(); nReadPos = 0; }"},
{"lineNum":"  244","line":"    iterator insert(iterator it, const char& x=char()) { return vch.insert(it, x); }"},
{"lineNum":"  245","line":"    void insert(iterator it, size_type n, const char& x) { vch.insert(it, n, x); }"},
{"lineNum":"  246","line":"    value_type* data()                               { return vch.data() + nReadPos; }"},
{"lineNum":"  247","line":"    const value_type* data() const                   { return vch.data() + nReadPos; }"},
{"lineNum":"  248","line":""},
{"lineNum":"  249","line":"    void insert(iterator it, std::vector<char>::const_iterator first, std::vector<char>::const_iterator last)"},
{"lineNum":"  250","line":"    {"},
{"lineNum":"  251","line":"        if (last == first) return;"},
{"lineNum":"  252","line":"        assert(last - first > 0);"},
{"lineNum":"  253","line":"        if (it == vch.begin() + nReadPos && (unsigned int)(last - first) <= nReadPos)"},
{"lineNum":"  254","line":"        {"},
{"lineNum":"  255","line":"            // special case for inserting at the front when there\'s room"},
{"lineNum":"  256","line":"            nReadPos -= (last - first);"},
{"lineNum":"  257","line":"            memcpy(&vch[nReadPos], &first[0], last - first);"},
{"lineNum":"  258","line":"        }"},
{"lineNum":"  259","line":"        else"},
{"lineNum":"  260","line":"            vch.insert(it, first, last);"},
{"lineNum":"  261","line":"    }"},
{"lineNum":"  262","line":""},
{"lineNum":"  263","line":"    void insert(iterator it, const char* first, const char* last)"},
{"lineNum":"  264","line":"    {"},
{"lineNum":"  265","line":"        if (last == first) return;"},
{"lineNum":"  266","line":"        assert(last - first > 0);"},
{"lineNum":"  267","line":"        if (it == vch.begin() + nReadPos && (unsigned int)(last - first) <= nReadPos)"},
{"lineNum":"  268","line":"        {"},
{"lineNum":"  269","line":"            // special case for inserting at the front when there\'s room"},
{"lineNum":"  270","line":"            nReadPos -= (last - first);"},
{"lineNum":"  271","line":"            memcpy(&vch[nReadPos], &first[0], last - first);"},
{"lineNum":"  272","line":"        }"},
{"lineNum":"  273","line":"        else"},
{"lineNum":"  274","line":"            vch.insert(it, first, last);"},
{"lineNum":"  275","line":"    }"},
{"lineNum":"  276","line":""},
{"lineNum":"  277","line":"    iterator erase(iterator it)"},
{"lineNum":"  278","line":"    {"},
{"lineNum":"  279","line":"        if (it == vch.begin() + nReadPos)"},
{"lineNum":"  280","line":"        {"},
{"lineNum":"  281","line":"            // special case for erasing from the front"},
{"lineNum":"  282","line":"            if (++nReadPos >= vch.size())"},
{"lineNum":"  283","line":"            {"},
{"lineNum":"  284","line":"                // whenever we reach the end, we take the opportunity to clear the buffer"},
{"lineNum":"  285","line":"                nReadPos = 0;"},
{"lineNum":"  286","line":"                return vch.erase(vch.begin(), vch.end());"},
{"lineNum":"  287","line":"            }"},
{"lineNum":"  288","line":"            return vch.begin() + nReadPos;"},
{"lineNum":"  289","line":"        }"},
{"lineNum":"  290","line":"        else"},
{"lineNum":"  291","line":"            return vch.erase(it);"},
{"lineNum":"  292","line":"    }"},
{"lineNum":"  293","line":""},
{"lineNum":"  294","line":"    iterator erase(iterator first, iterator last)"},
{"lineNum":"  295","line":"    {"},
{"lineNum":"  296","line":"        if (first == vch.begin() + nReadPos)"},
{"lineNum":"  297","line":"        {"},
{"lineNum":"  298","line":"            // special case for erasing from the front"},
{"lineNum":"  299","line":"            if (last == vch.end())"},
{"lineNum":"  300","line":"            {"},
{"lineNum":"  301","line":"                nReadPos = 0;"},
{"lineNum":"  302","line":"                return vch.erase(vch.begin(), vch.end());"},
{"lineNum":"  303","line":"            }"},
{"lineNum":"  304","line":"            else"},
{"lineNum":"  305","line":"            {"},
{"lineNum":"  306","line":"                nReadPos = (last - vch.begin());"},
{"lineNum":"  307","line":"                return last;"},
{"lineNum":"  308","line":"            }"},
{"lineNum":"  309","line":"        }"},
{"lineNum":"  310","line":"        else"},
{"lineNum":"  311","line":"            return vch.erase(first, last);"},
{"lineNum":"  312","line":"    }"},
{"lineNum":"  313","line":""},
{"lineNum":"  314","line":"    inline void Compact()"},
{"lineNum":"  315","line":"    {"},
{"lineNum":"  316","line":"        vch.erase(vch.begin(), vch.begin() + nReadPos);"},
{"lineNum":"  317","line":"        nReadPos = 0;"},
{"lineNum":"  318","line":"    }"},
{"lineNum":"  319","line":""},
{"lineNum":"  320","line":"    bool Rewind(size_type n)"},
{"lineNum":"  321","line":"    {"},
{"lineNum":"  322","line":"        // Rewind by n characters if the buffer hasn\'t been compacted yet"},
{"lineNum":"  323","line":"        if (n > nReadPos)"},
{"lineNum":"  324","line":"            return false;"},
{"lineNum":"  325","line":"        nReadPos -= n;"},
{"lineNum":"  326","line":"        return true;"},
{"lineNum":"  327","line":"    }"},
{"lineNum":"  328","line":""},
{"lineNum":"  329","line":""},
{"lineNum":"  330","line":"    //"},
{"lineNum":"  331","line":"    // Stream subset"},
{"lineNum":"  332","line":"    //"},
{"lineNum":"  333","line":"    bool eof() const             { return size() == 0; }"},
{"lineNum":"  334","line":"    CDataStream* rdbuf()         { return this; }"},
{"lineNum":"  335","line":"    int in_avail()               { return size(); }"},
{"lineNum":"  336","line":""},
{"lineNum":"  337","line":"    void SetType(int n)          { nType = n; }"},
{"lineNum":"  338","line":"    int GetType() const          { return nType; }"},
{"lineNum":"  339","line":"    void SetVersion(int n)       { nVersion = n; }"},
{"lineNum":"  340","line":"    int GetVersion() const       { return nVersion; }"},
{"lineNum":"  341","line":""},
{"lineNum":"  342","line":"    void read(char* pch, size_t nSize)"},
{"lineNum":"  343","line":"    {","class":"lineCov","hits":"2","order":"1413","possible_hits":"2",},
{"lineNum":"  344","line":"        if (nSize == 0) return;","class":"lineCov","hits":"1","order":"1414","possible_hits":"1",},
{"lineNum":"  345","line":""},
{"lineNum":"  346","line":"        // Read from the beginning of the buffer"},
{"lineNum":"  347","line":"        unsigned int nReadPosNext = nReadPos + nSize;","class":"lineCov","hits":"1","order":"1415","possible_hits":"1",},
{"lineNum":"  348","line":"        if (nReadPosNext >= vch.size())","class":"lineCov","hits":"1","order":"1416","possible_hits":"1",},
{"lineNum":"  349","line":"        {"},
{"lineNum":"  350","line":"            if (nReadPosNext > vch.size())","class":"lineCov","hits":"1","order":"1493","possible_hits":"1",},
{"lineNum":"  351","line":"            {"},
{"lineNum":"  352","line":"                throw std::ios_base::failure(\"CDataStream::read(): end of data\");","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  353","line":"            }"},
{"lineNum":"  354","line":"            memcpy(pch, &vch[nReadPos], nSize);","class":"lineCov","hits":"1","order":"1494","possible_hits":"1",},
{"lineNum":"  355","line":"            nReadPos = 0;","class":"lineCov","hits":"1","order":"1495","possible_hits":"1",},
{"lineNum":"  356","line":"            vch.clear();","class":"lineCov","hits":"1","order":"1496","possible_hits":"1",},
{"lineNum":"  357","line":"            return;","class":"lineCov","hits":"1","order":"1497","possible_hits":"1",},
{"lineNum":"  358","line":"        }"},
{"lineNum":"  359","line":"        memcpy(pch, &vch[nReadPos], nSize);","class":"lineCov","hits":"1","order":"1417","possible_hits":"1",},
{"lineNum":"  360","line":"        nReadPos = nReadPosNext;","class":"lineCov","hits":"1","order":"1418","possible_hits":"1",},
{"lineNum":"  361","line":"    }","class":"linePartCov","hits":"1","order":"1419","possible_hits":"2",},
{"lineNum":"  362","line":""},
{"lineNum":"  363","line":"    void ignore(int nSize)"},
{"lineNum":"  364","line":"    {"},
{"lineNum":"  365","line":"        // Ignore from the beginning of the buffer"},
{"lineNum":"  366","line":"        if (nSize < 0) {"},
{"lineNum":"  367","line":"            throw std::ios_base::failure(\"CDataStream::ignore(): nSize negative\");"},
{"lineNum":"  368","line":"        }"},
{"lineNum":"  369","line":"        unsigned int nReadPosNext = nReadPos + nSize;"},
{"lineNum":"  370","line":"        if (nReadPosNext >= vch.size())"},
{"lineNum":"  371","line":"        {"},
{"lineNum":"  372","line":"            if (nReadPosNext > vch.size())"},
{"lineNum":"  373","line":"                throw std::ios_base::failure(\"CDataStream::ignore(): end of data\");"},
{"lineNum":"  374","line":"            nReadPos = 0;"},
{"lineNum":"  375","line":"            vch.clear();"},
{"lineNum":"  376","line":"            return;"},
{"lineNum":"  377","line":"        }"},
{"lineNum":"  378","line":"        nReadPos = nReadPosNext;"},
{"lineNum":"  379","line":"    }"},
{"lineNum":"  380","line":""},
{"lineNum":"  381","line":"    void write(const char* pch, size_t nSize)"},
{"lineNum":"  382","line":"    {","class":"lineCov","hits":"2","order":"1353","possible_hits":"2",},
{"lineNum":"  383","line":"        // Write to the end of the buffer"},
{"lineNum":"  384","line":"        vch.insert(vch.end(), pch, pch + nSize);","class":"lineCov","hits":"1","order":"1354","possible_hits":"1",},
{"lineNum":"  385","line":"    }","class":"linePartCov","hits":"1","order":"1355","possible_hits":"2",},
{"lineNum":"  386","line":""},
{"lineNum":"  387","line":"    template<typename Stream>"},
{"lineNum":"  388","line":"    void Serialize(Stream& s) const"},
{"lineNum":"  389","line":"    {"},
{"lineNum":"  390","line":"        // Special case: stream << stream concatenates like stream += stream"},
{"lineNum":"  391","line":"        if (!vch.empty())"},
{"lineNum":"  392","line":"            s.write((char*)&vch[0], vch.size() * sizeof(vch[0]));"},
{"lineNum":"  393","line":"    }"},
{"lineNum":"  394","line":""},
{"lineNum":"  395","line":"    template<typename T>"},
{"lineNum":"  396","line":"    CDataStream& operator<<(const T& obj)"},
{"lineNum":"  397","line":"    {","class":"lineCov","hits":"2","order":"1337","possible_hits":"2",},
{"lineNum":"  398","line":"        // Serialize to this stream"},
{"lineNum":"  399","line":"        ::Serialize(*this, obj);","class":"lineCov","hits":"1","order":"1338","possible_hits":"1",},
{"lineNum":"  400","line":"        return (*this);","class":"lineCov","hits":"2","order":"1400","possible_hits":"2",},
{"lineNum":"  401","line":"    }"},
{"lineNum":"  402","line":""},
{"lineNum":"  403","line":"    template<typename T>"},
{"lineNum":"  404","line":"    CDataStream& operator>>(T& obj)"},
{"lineNum":"  405","line":"    {","class":"lineCov","hits":"2","order":"1403","possible_hits":"2",},
{"lineNum":"  406","line":"        // Unserialize from this stream"},
{"lineNum":"  407","line":"        ::Unserialize(*this, obj);","class":"lineCov","hits":"1","order":"1404","possible_hits":"1",},
{"lineNum":"  408","line":"        return (*this);","class":"lineCov","hits":"2","order":"1498","possible_hits":"2",},
{"lineNum":"  409","line":"    }"},
{"lineNum":"  410","line":""},
{"lineNum":"  411","line":"    void GetAndClear(CSerializeData &data) {"},
{"lineNum":"  412","line":"        data.insert(data.end(), begin(), end());"},
{"lineNum":"  413","line":"        clear();"},
{"lineNum":"  414","line":"    }"},
{"lineNum":"  415","line":""},
{"lineNum":"  416","line":"    /**"},
{"lineNum":"  417","line":"     * XOR the contents of this stream with a certain key."},
{"lineNum":"  418","line":"     *"},
{"lineNum":"  419","line":"     * @param[in] key    The key used to XOR the data in this stream."},
{"lineNum":"  420","line":"     */"},
{"lineNum":"  421","line":"    void Xor(const std::vector<unsigned char>& key)"},
{"lineNum":"  422","line":"    {"},
{"lineNum":"  423","line":"        if (key.size() == 0) {"},
{"lineNum":"  424","line":"            return;"},
{"lineNum":"  425","line":"        }"},
{"lineNum":"  426","line":""},
{"lineNum":"  427","line":"        for (size_type i = 0, j = 0; i != size(); i++) {"},
{"lineNum":"  428","line":"            vch[i] ^= key[j++];"},
{"lineNum":"  429","line":""},
{"lineNum":"  430","line":"            // This potentially acts on very many bytes of data, so it\'s"},
{"lineNum":"  431","line":"            // important that we calculate `j`, i.e. the `key` index in this"},
{"lineNum":"  432","line":"            // way instead of doing a %, which would effectively be a division"},
{"lineNum":"  433","line":"            // for each byte Xor\'d -- much slower than need be."},
{"lineNum":"  434","line":"            if (j == key.size())"},
{"lineNum":"  435","line":"                j = 0;"},
{"lineNum":"  436","line":"        }"},
{"lineNum":"  437","line":"    }"},
{"lineNum":"  438","line":"};"},
{"lineNum":"  439","line":""},
{"lineNum":"  440","line":""},
{"lineNum":"  441","line":""},
{"lineNum":"  442","line":""},
{"lineNum":"  443","line":""},
{"lineNum":"  444","line":""},
{"lineNum":"  445","line":""},
{"lineNum":"  446","line":""},
{"lineNum":"  447","line":""},
{"lineNum":"  448","line":""},
{"lineNum":"  449","line":"/** Non-refcounted RAII wrapper for FILE*"},
{"lineNum":"  450","line":" *"},
{"lineNum":"  451","line":" * Will automatically close the file when it goes out of scope if not null."},
{"lineNum":"  452","line":" * If you\'re returning the file pointer, return file.release()."},
{"lineNum":"  453","line":" * If you need to close the file early, use file.fclose() instead of fclose(file)."},
{"lineNum":"  454","line":" */"},
{"lineNum":"  455","line":"class CAutoFile"},
{"lineNum":"  456","line":"{"},
{"lineNum":"  457","line":"private:"},
{"lineNum":"  458","line":"    // Disallow copies"},
{"lineNum":"  459","line":"    CAutoFile(const CAutoFile&);"},
{"lineNum":"  460","line":"    CAutoFile& operator=(const CAutoFile&);"},
{"lineNum":"  461","line":""},
{"lineNum":"  462","line":"    const int nType;"},
{"lineNum":"  463","line":"    const int nVersion;"},
{"lineNum":"  464","line":""},
{"lineNum":"  465","line":"    FILE* file;"},
{"lineNum":"  466","line":""},
{"lineNum":"  467","line":"public:"},
{"lineNum":"  468","line":"    CAutoFile(FILE* filenew, int nTypeIn, int nVersionIn) : nType(nTypeIn), nVersion(nVersionIn)"},
{"lineNum":"  469","line":"    {"},
{"lineNum":"  470","line":"        file = filenew;"},
{"lineNum":"  471","line":"    }"},
{"lineNum":"  472","line":""},
{"lineNum":"  473","line":"    ~CAutoFile()"},
{"lineNum":"  474","line":"    {"},
{"lineNum":"  475","line":"        fclose();"},
{"lineNum":"  476","line":"    }"},
{"lineNum":"  477","line":""},
{"lineNum":"  478","line":"    void fclose()"},
{"lineNum":"  479","line":"    {"},
{"lineNum":"  480","line":"        if (file) {"},
{"lineNum":"  481","line":"            ::fclose(file);"},
{"lineNum":"  482","line":"            file = NULL;"},
{"lineNum":"  483","line":"        }"},
{"lineNum":"  484","line":"    }"},
{"lineNum":"  485","line":""},
{"lineNum":"  486","line":"    /** Get wrapped FILE* with transfer of ownership."},
{"lineNum":"  487","line":"     * @note This will invalidate the CAutoFile object, and makes it the responsibility of the caller"},
{"lineNum":"  488","line":"     * of this function to clean up the returned FILE*."},
{"lineNum":"  489","line":"     */"},
{"lineNum":"  490","line":"    FILE* release()             { FILE* ret = file; file = NULL; return ret; }"},
{"lineNum":"  491","line":""},
{"lineNum":"  492","line":"    /** Get wrapped FILE* without transfer of ownership."},
{"lineNum":"  493","line":"     * @note Ownership of the FILE* will remain with this class. Use this only if the scope of the"},
{"lineNum":"  494","line":"     * CAutoFile outlives use of the passed pointer."},
{"lineNum":"  495","line":"     */"},
{"lineNum":"  496","line":"    FILE* Get() const           { return file; }"},
{"lineNum":"  497","line":""},
{"lineNum":"  498","line":"    /** Return true if the wrapped FILE* is NULL, false otherwise."},
{"lineNum":"  499","line":"     */"},
{"lineNum":"  500","line":"    bool IsNull() const         { return (file == NULL); }"},
{"lineNum":"  501","line":""},
{"lineNum":"  502","line":"    //"},
{"lineNum":"  503","line":"    // Stream subset"},
{"lineNum":"  504","line":"    //"},
{"lineNum":"  505","line":"    int GetType() const          { return nType; }"},
{"lineNum":"  506","line":"    int GetVersion() const       { return nVersion; }"},
{"lineNum":"  507","line":""},
{"lineNum":"  508","line":"    void read(char* pch, size_t nSize)"},
{"lineNum":"  509","line":"    {"},
{"lineNum":"  510","line":"        if (!file)"},
{"lineNum":"  511","line":"            throw std::ios_base::failure(\"CAutoFile::read: file handle is NULL\");"},
{"lineNum":"  512","line":"        if (fread(pch, 1, nSize, file) != nSize)"},
{"lineNum":"  513","line":"            throw std::ios_base::failure(feof(file) ? \"CAutoFile::read: end of file\" : \"CAutoFile::read: fread failed\");"},
{"lineNum":"  514","line":"    }"},
{"lineNum":"  515","line":""},
{"lineNum":"  516","line":"    void ignore(size_t nSize)"},
{"lineNum":"  517","line":"    {"},
{"lineNum":"  518","line":"        if (!file)"},
{"lineNum":"  519","line":"            throw std::ios_base::failure(\"CAutoFile::ignore: file handle is NULL\");"},
{"lineNum":"  520","line":"        unsigned char data[4096];"},
{"lineNum":"  521","line":"        while (nSize > 0) {"},
{"lineNum":"  522","line":"            size_t nNow = std::min<size_t>(nSize, sizeof(data));"},
{"lineNum":"  523","line":"            if (fread(data, 1, nNow, file) != nNow)"},
{"lineNum":"  524","line":"                throw std::ios_base::failure(feof(file) ? \"CAutoFile::ignore: end of file\" : \"CAutoFile::read: fread failed\");"},
{"lineNum":"  525","line":"            nSize -= nNow;"},
{"lineNum":"  526","line":"        }"},
{"lineNum":"  527","line":"    }"},
{"lineNum":"  528","line":""},
{"lineNum":"  529","line":"    void write(const char* pch, size_t nSize)"},
{"lineNum":"  530","line":"    {"},
{"lineNum":"  531","line":"        if (!file)"},
{"lineNum":"  532","line":"            throw std::ios_base::failure(\"CAutoFile::write: file handle is NULL\");"},
{"lineNum":"  533","line":"        if (fwrite(pch, 1, nSize, file) != nSize)"},
{"lineNum":"  534","line":"            throw std::ios_base::failure(\"CAutoFile::write: write failed\");"},
{"lineNum":"  535","line":"    }"},
{"lineNum":"  536","line":""},
{"lineNum":"  537","line":"    template<typename T>"},
{"lineNum":"  538","line":"    CAutoFile& operator<<(const T& obj)"},
{"lineNum":"  539","line":"    {"},
{"lineNum":"  540","line":"        // Serialize to this stream"},
{"lineNum":"  541","line":"        if (!file)"},
{"lineNum":"  542","line":"            throw std::ios_base::failure(\"CAutoFile::operator<<: file handle is NULL\");"},
{"lineNum":"  543","line":"        ::Serialize(*this, obj);"},
{"lineNum":"  544","line":"        return (*this);"},
{"lineNum":"  545","line":"    }"},
{"lineNum":"  546","line":""},
{"lineNum":"  547","line":"    template<typename T>"},
{"lineNum":"  548","line":"    CAutoFile& operator>>(T& obj)"},
{"lineNum":"  549","line":"    {"},
{"lineNum":"  550","line":"        // Unserialize from this stream"},
{"lineNum":"  551","line":"        if (!file)"},
{"lineNum":"  552","line":"            throw std::ios_base::failure(\"CAutoFile::operator>>: file handle is NULL\");"},
{"lineNum":"  553","line":"        ::Unserialize(*this, obj);"},
{"lineNum":"  554","line":"        return (*this);"},
{"lineNum":"  555","line":"    }"},
{"lineNum":"  556","line":"};"},
{"lineNum":"  557","line":""},
{"lineNum":"  558","line":"/** Non-refcounted RAII wrapper around a FILE* that implements a ring buffer to"},
{"lineNum":"  559","line":" *  deserialize from. It guarantees the ability to rewind a given number of bytes."},
{"lineNum":"  560","line":" *"},
{"lineNum":"  561","line":" *  Will automatically close the file when it goes out of scope if not null."},
{"lineNum":"  562","line":" *  If you need to close the file early, use file.fclose() instead of fclose(file)."},
{"lineNum":"  563","line":" */"},
{"lineNum":"  564","line":"class CBufferedFile"},
{"lineNum":"  565","line":"{"},
{"lineNum":"  566","line":"private:"},
{"lineNum":"  567","line":"    // Disallow copies"},
{"lineNum":"  568","line":"    CBufferedFile(const CBufferedFile&);"},
{"lineNum":"  569","line":"    CBufferedFile& operator=(const CBufferedFile&);"},
{"lineNum":"  570","line":""},
{"lineNum":"  571","line":"    const int nType;"},
{"lineNum":"  572","line":"    const int nVersion;"},
{"lineNum":"  573","line":""},
{"lineNum":"  574","line":"    FILE *src;            // source file"},
{"lineNum":"  575","line":"    uint64_t nSrcPos;     // how many bytes have been read from source"},
{"lineNum":"  576","line":"    uint64_t nReadPos;    // how many bytes have been read from this"},
{"lineNum":"  577","line":"    uint64_t nReadLimit;  // up to which position we\'re allowed to read"},
{"lineNum":"  578","line":"    uint64_t nRewind;     // how many bytes we guarantee to rewind"},
{"lineNum":"  579","line":"    std::vector<char> vchBuf; // the buffer"},
{"lineNum":"  580","line":""},
{"lineNum":"  581","line":"protected:"},
{"lineNum":"  582","line":"    // read data from the source to fill the buffer"},
{"lineNum":"  583","line":"    bool Fill() {"},
{"lineNum":"  584","line":"        unsigned int pos = nSrcPos % vchBuf.size();"},
{"lineNum":"  585","line":"        unsigned int readNow = vchBuf.size() - pos;"},
{"lineNum":"  586","line":"        unsigned int nAvail = vchBuf.size() - (nSrcPos - nReadPos) - nRewind;"},
{"lineNum":"  587","line":"        if (nAvail < readNow)"},
{"lineNum":"  588","line":"            readNow = nAvail;"},
{"lineNum":"  589","line":"        if (readNow == 0)"},
{"lineNum":"  590","line":"            return false;"},
{"lineNum":"  591","line":"        size_t read = fread((void*)&vchBuf[pos], 1, readNow, src);"},
{"lineNum":"  592","line":"        if (read == 0) {"},
{"lineNum":"  593","line":"            throw std::ios_base::failure(feof(src) ? \"CBufferedFile::Fill: end of file\" : \"CBufferedFile::Fill: fread failed\");"},
{"lineNum":"  594","line":"        } else {"},
{"lineNum":"  595","line":"            nSrcPos += read;"},
{"lineNum":"  596","line":"            return true;"},
{"lineNum":"  597","line":"        }"},
{"lineNum":"  598","line":"    }"},
{"lineNum":"  599","line":""},
{"lineNum":"  600","line":"public:"},
{"lineNum":"  601","line":"    CBufferedFile(FILE *fileIn, uint64_t nBufSize, uint64_t nRewindIn, int nTypeIn, int nVersionIn) :"},
{"lineNum":"  602","line":"        nType(nTypeIn), nVersion(nVersionIn), nSrcPos(0), nReadPos(0), nReadLimit((uint64_t)(-1)), nRewind(nRewindIn), vchBuf(nBufSize, 0)"},
{"lineNum":"  603","line":"    {"},
{"lineNum":"  604","line":"        src = fileIn;"},
{"lineNum":"  605","line":"    }"},
{"lineNum":"  606","line":""},
{"lineNum":"  607","line":"    ~CBufferedFile()"},
{"lineNum":"  608","line":"    {"},
{"lineNum":"  609","line":"        fclose();"},
{"lineNum":"  610","line":"    }"},
{"lineNum":"  611","line":""},
{"lineNum":"  612","line":"    int GetVersion() const { return nVersion; }"},
{"lineNum":"  613","line":"    int GetType() const { return nType; }"},
{"lineNum":"  614","line":""},
{"lineNum":"  615","line":"    void fclose()"},
{"lineNum":"  616","line":"    {"},
{"lineNum":"  617","line":"        if (src) {"},
{"lineNum":"  618","line":"            ::fclose(src);"},
{"lineNum":"  619","line":"            src = NULL;"},
{"lineNum":"  620","line":"        }"},
{"lineNum":"  621","line":"    }"},
{"lineNum":"  622","line":""},
{"lineNum":"  623","line":"    // check whether we\'re at the end of the source file"},
{"lineNum":"  624","line":"    bool eof() const {"},
{"lineNum":"  625","line":"        return nReadPos == nSrcPos && feof(src);"},
{"lineNum":"  626","line":"    }"},
{"lineNum":"  627","line":""},
{"lineNum":"  628","line":"    // read a number of bytes"},
{"lineNum":"  629","line":"    void read(char *pch, size_t nSize) {"},
{"lineNum":"  630","line":"        if (nSize + nReadPos > nReadLimit)"},
{"lineNum":"  631","line":"            throw std::ios_base::failure(\"Read attempted past buffer limit\");"},
{"lineNum":"  632","line":"        if (nSize + nRewind > vchBuf.size())"},
{"lineNum":"  633","line":"            throw std::ios_base::failure(\"Read larger than buffer size\");"},
{"lineNum":"  634","line":"        while (nSize > 0) {"},
{"lineNum":"  635","line":"            if (nReadPos == nSrcPos)"},
{"lineNum":"  636","line":"                Fill();"},
{"lineNum":"  637","line":"            unsigned int pos = nReadPos % vchBuf.size();"},
{"lineNum":"  638","line":"            size_t nNow = nSize;"},
{"lineNum":"  639","line":"            if (nNow + pos > vchBuf.size())"},
{"lineNum":"  640","line":"                nNow = vchBuf.size() - pos;"},
{"lineNum":"  641","line":"            if (nNow + nReadPos > nSrcPos)"},
{"lineNum":"  642","line":"                nNow = nSrcPos - nReadPos;"},
{"lineNum":"  643","line":"            memcpy(pch, &vchBuf[pos], nNow);"},
{"lineNum":"  644","line":"            nReadPos += nNow;"},
{"lineNum":"  645","line":"            pch += nNow;"},
{"lineNum":"  646","line":"            nSize -= nNow;"},
{"lineNum":"  647","line":"        }"},
{"lineNum":"  648","line":"    }"},
{"lineNum":"  649","line":""},
{"lineNum":"  650","line":"    // return the current reading position"},
{"lineNum":"  651","line":"    uint64_t GetPos() {"},
{"lineNum":"  652","line":"        return nReadPos;"},
{"lineNum":"  653","line":"    }"},
{"lineNum":"  654","line":""},
{"lineNum":"  655","line":"    // rewind to a given reading position"},
{"lineNum":"  656","line":"    bool SetPos(uint64_t nPos) {"},
{"lineNum":"  657","line":"        nReadPos = nPos;"},
{"lineNum":"  658","line":"        if (nReadPos + nRewind < nSrcPos) {"},
{"lineNum":"  659","line":"            nReadPos = nSrcPos - nRewind;"},
{"lineNum":"  660","line":"            return false;"},
{"lineNum":"  661","line":"        } else if (nReadPos > nSrcPos) {"},
{"lineNum":"  662","line":"            nReadPos = nSrcPos;"},
{"lineNum":"  663","line":"            return false;"},
{"lineNum":"  664","line":"        } else {"},
{"lineNum":"  665","line":"            return true;"},
{"lineNum":"  666","line":"        }"},
{"lineNum":"  667","line":"    }"},
{"lineNum":"  668","line":""},
{"lineNum":"  669","line":"    bool Seek(uint64_t nPos) {"},
{"lineNum":"  670","line":"        long nLongPos = nPos;"},
{"lineNum":"  671","line":"        if (nPos != (uint64_t)nLongPos)"},
{"lineNum":"  672","line":"            return false;"},
{"lineNum":"  673","line":"        if (fseek(src, nLongPos, SEEK_SET))"},
{"lineNum":"  674","line":"            return false;"},
{"lineNum":"  675","line":"        nLongPos = ftell(src);"},
{"lineNum":"  676","line":"        nSrcPos = nLongPos;"},
{"lineNum":"  677","line":"        nReadPos = nLongPos;"},
{"lineNum":"  678","line":"        return true;"},
{"lineNum":"  679","line":"    }"},
{"lineNum":"  680","line":""},
{"lineNum":"  681","line":"    // prevent reading beyond a certain position"},
{"lineNum":"  682","line":"    // no argument removes the limit"},
{"lineNum":"  683","line":"    bool SetLimit(uint64_t nPos = (uint64_t)(-1)) {"},
{"lineNum":"  684","line":"        if (nPos < nReadPos)"},
{"lineNum":"  685","line":"            return false;"},
{"lineNum":"  686","line":"        nReadLimit = nPos;"},
{"lineNum":"  687","line":"        return true;"},
{"lineNum":"  688","line":"    }"},
{"lineNum":"  689","line":""},
{"lineNum":"  690","line":"    template<typename T>"},
{"lineNum":"  691","line":"    CBufferedFile& operator>>(T& obj) {"},
{"lineNum":"  692","line":"        // Unserialize from this stream"},
{"lineNum":"  693","line":"        ::Unserialize(*this, obj);"},
{"lineNum":"  694","line":"        return (*this);"},
{"lineNum":"  695","line":"    }"},
{"lineNum":"  696","line":""},
{"lineNum":"  697","line":"    // search for a given byte in the stream, and remain positioned on it"},
{"lineNum":"  698","line":"    void FindByte(char ch) {"},
{"lineNum":"  699","line":"        while (true) {"},
{"lineNum":"  700","line":"            if (nReadPos == nSrcPos)"},
{"lineNum":"  701","line":"                Fill();"},
{"lineNum":"  702","line":"            if (vchBuf[nReadPos % vchBuf.size()] == ch)"},
{"lineNum":"  703","line":"                break;"},
{"lineNum":"  704","line":"            nReadPos++;"},
{"lineNum":"  705","line":"        }"},
{"lineNum":"  706","line":"    }"},
{"lineNum":"  707","line":"};"},
{"lineNum":"  708","line":""},
{"lineNum":"  709","line":"#endif // BITCOIN_STREAMS_H"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "chaum_fuzz_debug", "date" : "2023-08-09 12:14:03", "instrumented" : 32, "covered" : 30,};
var merged_data = [];
